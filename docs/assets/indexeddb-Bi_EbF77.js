import{o as m}from"./vendor-idb-Dob3nYDb.js";function b(w,r){const t=r.split(".");let e=w;for(const n of t){if(e==null||typeof e!="object")return;e=e[n]}return e}function B(w,r){const t=b(w,r.field),e=r.value;switch(r.operator){case"=":return t===e;case"!=":return t!==e;case">":return t>e;case"<":return t<e;case">=":return t>=e;case"<=":return t<=e;case"in":return Array.isArray(e)&&e.includes(t);case"notIn":return Array.isArray(e)&&!e.includes(t);case"contains":return typeof t=="string"&&typeof e=="string"&&t.includes(e);case"startsWith":return typeof t=="string"&&typeof e=="string"&&t.startsWith(e);case"between":{if(!Array.isArray(e)||e.length!==2)return!1;const n=t;return n>=e[0]&&n<=e[1]}case"isNull":return t==null;case"isNotNull":return t!=null;default:return!1}}function y(w,r){return w.filter(t=>r.every(e=>B(t,e)))}function D(w,r){const t=[...w];return t.sort((e,n)=>{for(const{field:a,direction:u}of r){const i=b(e,a),s=b(n,a);let o=0;if(i==null&&s==null?o=0:i==null?o=-1:s==null?o=1:typeof i=="string"&&typeof s=="string"?o=i.localeCompare(s):typeof i=="number"&&typeof s=="number"?o=i-s:o=String(i).localeCompare(String(s)),o!==0)return u==="desc"?-o:o}return 0}),t}const v="concrete";class k{db=null;knownStores=new Set;version=1;async ensureDB(r){if(this.db&&(!r||this.knownStores.has(r)))return this.db;r&&this.knownStores.add(r),this.db&&(this.db.close(),this.db=null,this.version++);const t=[...this.knownStores],e=this.version;return this.db=await m(v,e,{upgrade(n){for(const a of t)n.objectStoreNames.contains(a)||n.createObjectStore(a,{keyPath:"id"})}}),this.db}async get(r,t){return await(await this.ensureDB(r)).get(r,t)??null}async getAll(r){return await(await this.ensureDB(r)).getAll(r)}async insert(r,t){const e=await this.ensureDB(r),n={...t};return await e.put(r,n),n}async update(r,t,e){const n=await this.ensureDB(r),a=await n.get(r,t);if(!a)throw new Error(`[IndexedDBAdapter] Record not found: ${r}/${t}`);const u={...a,...e};return await n.put(r,u),u}async upsert(r,t){const e=await this.ensureDB(r),n=t.id;if(n){const u=await e.get(r,n);if(u){const i={...u,...t};return await e.put(r,i),i}}const a={...t};return await e.put(r,a),a}async remove(r,t){await(await this.ensureDB(r)).delete(r,t)}async query(r,t){let e=await this.getAll(r);return t.filters&&t.filters.length>0&&(e=y(e,t.filters)),t.orderBy&&t.orderBy.length>0&&(e=D(e,t.orderBy)),t.offset!=null&&t.offset>0&&(e=e.slice(t.offset)),t.limit!=null&&t.limit>0&&(e=e.slice(0,t.limit)),e}async count(r,t){if(!t||t.length===0)return await(await this.ensureDB(r)).count(r);const e=await this.getAll(r);return y(e,t).length}async bulkInsert(r,t,e){const a=(await this.ensureDB(r)).transaction(r,"readwrite"),u=a.objectStore(r),i=[],s=t.length;for(let o=0;o<s;o++){const l={...t[o]};await u.put(l),i.push(l),e?.onProgress&&s>0&&e.onProgress(Math.round((o+1)/s*100))}return await a.done,i}async bulkUpdate(r,t,e){const a=(await this.ensureDB(r)).transaction(r,"readwrite"),u=a.objectStore(r),i=[],s=t.length;for(let o=0;o<s;o++){const{id:l,changes:g}=t[o],f=await u.get(l);if(!f)throw new Error(`[IndexedDBAdapter] Record not found: ${r}/${l}`);const c={...f,...g};await u.put(c),i.push(c),e?.onProgress&&s>0&&e.onProgress(Math.round((o+1)/s*100))}return await a.done,i}async bulkRemove(r,t,e){const a=(await this.ensureDB(r)).transaction(r,"readwrite"),u=a.objectStore(r),i=t.length;for(let s=0;s<i;s++)await u.delete(t[s]),e?.onProgress&&i>0&&e.onProgress(Math.round((s+1)/i*100));await a.done}async aggregate(r,t){let e=await this.getAll(r);t.filters&&t.filters.length>0&&(e=y(e,t.filters));const n=t.groupBy??[],a=new Map;for(const i of e){const s=n.map(o=>String(b(i,o)??"")).join("||");a.has(s)||a.set(s,[]),a.get(s).push(i)}n.length===0&&!a.has("")&&a.set("",e);const u=[];for(const[i,s]of a.entries()){const o={};if(n.length>0){const g=i.split("||");for(let f=0;f<n.length;f++)o[n[f]]=g[f]}const l={};for(const g of t.aggregates){const f=`${g.fn}_${g.field}`;switch(g.fn){case"count":l[f]=s.length;break;case"sum":{let c=0;for(const h of s){const d=b(h,g.field);typeof d=="number"&&(c+=d)}l[f]=c;break}case"avg":{let c=0,h=0;for(const d of s){const p=b(d,g.field);typeof p=="number"&&(c+=p,h++)}l[f]=h>0?c/h:0;break}case"min":{let c=1/0;for(const h of s){const d=b(h,g.field);typeof d=="number"&&d<c&&(c=d)}l[f]=c===1/0?0:c;break}case"max":{let c=-1/0;for(const h of s){const d=b(h,g.field);typeof d=="number"&&d>c&&(c=d)}l[f]=c===-1/0?0:c;break}}}u.push({groups:o,values:l})}return u}async clear(r){await(await this.ensureDB(r)).clear(r)}async exportCollection(r){return this.getAll(r)}async importCollection(r,t,e=!1){const n=await this.ensureDB(r);e||await n.clear(r);const a=n.transaction(r,"readwrite"),u=a.objectStore(r);for(const i of t){if(e){const s=i.id;if(s){const o=await u.get(s);if(o){await u.put({...o,...i});continue}}}await u.put({...i})}await a.done}close(){this.db&&(this.db.close(),this.db=null)}}export{k as IndexedDBAdapter};
