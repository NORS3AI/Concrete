import{o as p}from"./vendor-idb-Dob3nYDb.js";import{a as l,b as m,g as b}from"./index-UReCnmp3.js";import"./module-gl-DpMMjp0h.js";import"./module-entity-IhVmVdGG.js";import"./module-job-DtsScTih.js";import"./module-ap-B_XWtQd0.js";const B="concrete";class P{db=null;knownStores=new Set;version=1;async ensureDB(t){if(this.db&&(!t||this.knownStores.has(t)))return this.db;t&&this.knownStores.add(t),this.db&&(this.db.close(),this.db=null,this.version++);const e=[...this.knownStores],s=this.version;return this.db=await p(B,s,{upgrade(n){for(const r of e)n.objectStoreNames.contains(r)||n.createObjectStore(r,{keyPath:"id"})}}),this.db}async get(t,e){return await(await this.ensureDB(t)).get(t,e)??null}async getAll(t){return await(await this.ensureDB(t)).getAll(t)}async insert(t,e){const s=await this.ensureDB(t),n={...e};return await s.put(t,n),n}async update(t,e,s){const n=await this.ensureDB(t),r=await n.get(t,e);if(!r)throw new Error(`[IndexedDBAdapter] Record not found: ${t}/${e}`);const o={...r,...s};return await n.put(t,o),o}async upsert(t,e){const s=await this.ensureDB(t),n=e.id;if(n){const o=await s.get(t,n);if(o){const i={...o,...e};return await s.put(t,i),i}}const r={...e};return await s.put(t,r),r}async remove(t,e){await(await this.ensureDB(t)).delete(t,e)}async query(t,e){let s=await this.getAll(t);return e.filters&&e.filters.length>0&&(s=l(s,e.filters)),e.orderBy&&e.orderBy.length>0&&(s=m(s,e.orderBy)),e.offset!=null&&e.offset>0&&(s=s.slice(e.offset)),e.limit!=null&&e.limit>0&&(s=s.slice(0,e.limit)),s}async count(t,e){if(!e||e.length===0)return await(await this.ensureDB(t)).count(t);const s=await this.getAll(t);return l(s,e).length}async bulkInsert(t,e,s){const r=(await this.ensureDB(t)).transaction(t,"readwrite"),o=r.objectStore(t),i=[],a=e.length;for(let f=0;f<a;f++){const c={...e[f]};await o.put(c),i.push(c),s?.onProgress&&a>0&&s.onProgress(Math.round((f+1)/a*100))}return await r.done,i}async bulkUpdate(t,e,s){const r=(await this.ensureDB(t)).transaction(t,"readwrite"),o=r.objectStore(t),i=[],a=e.length;for(let f=0;f<a;f++){const{id:c,changes:g}=e[f],d=await o.get(c);if(!d)throw new Error(`[IndexedDBAdapter] Record not found: ${t}/${c}`);const u={...d,...g};await o.put(u),i.push(u),s?.onProgress&&a>0&&s.onProgress(Math.round((f+1)/a*100))}return await r.done,i}async bulkRemove(t,e,s){const r=(await this.ensureDB(t)).transaction(t,"readwrite"),o=r.objectStore(t),i=e.length;for(let a=0;a<i;a++)await o.delete(e[a]),s?.onProgress&&i>0&&s.onProgress(Math.round((a+1)/i*100));await r.done}async aggregate(t,e){let s=await this.getAll(t);e.filters&&e.filters.length>0&&(s=l(s,e.filters));const n=e.groupBy??[],r=new Map;for(const i of s){const a=n.map(f=>String(b(i,f)??"")).join("||");r.has(a)||r.set(a,[]),r.get(a).push(i)}n.length===0&&!r.has("")&&r.set("",s);const o=[];for(const[i,a]of r.entries()){const f={};if(n.length>0){const g=i.split("||");for(let d=0;d<n.length;d++)f[n[d]]=g[d]}const c={};for(const g of e.aggregates){const d=`${g.fn}_${g.field}`;switch(g.fn){case"count":c[d]=a.length;break;case"sum":{let u=0;for(const w of a){const h=b(w,g.field);typeof h=="number"&&(u+=h)}c[d]=u;break}case"avg":{let u=0,w=0;for(const h of a){const y=b(h,g.field);typeof y=="number"&&(u+=y,w++)}c[d]=w>0?u/w:0;break}case"min":{let u=1/0;for(const w of a){const h=b(w,g.field);typeof h=="number"&&h<u&&(u=h)}c[d]=u===1/0?0:u;break}case"max":{let u=-1/0;for(const w of a){const h=b(w,g.field);typeof h=="number"&&h>u&&(u=h)}c[d]=u===-1/0?0:u;break}}}o.push({groups:f,values:c})}return o}async clear(t){await(await this.ensureDB(t)).clear(t)}async exportCollection(t){return this.getAll(t)}async importCollection(t,e,s=!1){const n=await this.ensureDB(t);s||await n.clear(t);const r=n.transaction(t,"readwrite"),o=r.objectStore(t);for(const i of e){if(s){const a=i.id;if(a){const f=await o.get(a);if(f){await o.put({...f,...i});continue}}}await o.put({...i})}await r.done}close(){this.db&&(this.db.close(),this.db=null)}}export{P as IndexedDBAdapter};
