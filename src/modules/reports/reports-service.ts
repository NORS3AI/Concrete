/**
 * Concrete -- Reports Service (Financial Reporting Suite - Phase 11)
 *
 * Core service layer for the Financial Reporting module. Generates balance
 * sheets, income statements, cash flow statements, WIP schedules, job cost
 * summaries, aged AP/AR reports, payroll summaries, equipment utilization
 * reports, bonding capacity analysis, and custom report templates.
 *
 * This module reads from other modules' data -- it does NOT own any schema
 * collections. It takes Collection references to GL, AR, AP, payroll, job,
 * and entity data in its constructor.
 */

import type { Collection, CollectionMeta } from '../../core/store/collection';
import type { EventBus } from '../../core/events/bus';

// ---------------------------------------------------------------------------
// Enums / Literal Types
// ---------------------------------------------------------------------------

export type ReportType =
  | 'balance-sheet'
  | 'income-statement'
  | 'cash-flow'
  | 'wip-schedule'
  | 'job-cost-summary'
  | 'job-cost-detail'
  | 'aging-ap'
  | 'aging-ar'
  | 'payroll-summary'
  | 'payroll-detail'
  | 'equipment-utilization'
  | 'equipment-cost'
  | 'bonding-capacity'
  | 'custom';

export type ReportFormat = 'pdf' | 'csv' | 'excel' | 'json';

export type ComparativePeriod = 'month' | 'quarter' | 'year' | 'ytd';

export type BalanceSheetStyle = 'standard' | 'comparative' | 'consolidated';

export type IncomeStatementStyle = 'standard' | 'by-job' | 'by-entity' | 'comparative';

export type CashFlowMethod = 'direct' | 'indirect';

export type WipMethod = 'cost' | 'units' | 'efforts';

export type CashFlowCategory = 'operating' | 'investing' | 'financing';

export type IncomeCategory = 'revenue' | 'cogs' | 'expense' | 'other';

// ---------------------------------------------------------------------------
// GL Interfaces (referenced from GL module)
// ---------------------------------------------------------------------------

export interface GLAccountRef {
  [key: string]: unknown;
  number: string;
  name: string;
  type: string;
  normalBalance: string;
  parentId?: string;
  isActive: boolean;
  depth: number;
  path: string;
  isSummary: boolean;
}

export interface GLJournalEntryRef {
  [key: string]: unknown;
  entryNumber: string;
  date: string;
  reference?: string;
  description?: string;
  status: string;
  totalDebit: number;
  totalCredit: number;
  sourceModule?: string;
  sourceId?: string;
  fiscalPeriodId?: string;
  isAutoGenerated: boolean;
}

export interface GLJournalLineRef {
  [key: string]: unknown;
  journalEntryId: string;
  accountId: string;
  accountNumber?: string;
  accountName?: string;
  debit: number;
  credit: number;
  description?: string;
  lineOrder: number;
}

export interface GLFiscalPeriodRef {
  [key: string]: unknown;
  name: string;
  year: number;
  month?: number;
  startDate: string;
  endDate: string;
  status: string;
}

// ---------------------------------------------------------------------------
// AP/AR Interfaces (referenced from AP/AR modules)
// ---------------------------------------------------------------------------

export interface APInvoiceRef {
  [key: string]: unknown;
  vendorId: string;
  invoiceNumber: string;
  invoiceDate: string;
  dueDate?: string;
  amount: number;
  paidAmount: number;
  balanceDue: number;
  status: string;
  jobId?: string;
  entityId?: string;
}

export interface APVendorRef {
  [key: string]: unknown;
  name: string;
  code?: string;
  status: string;
}

export interface ARInvoiceRef {
  [key: string]: unknown;
  customerId: string;
  invoiceNumber: string;
  invoiceDate: string;
  dueDate?: string;
  amount: number;
  paidAmount: number;
  balanceDue: number;
  status: string;
  jobId?: string;
}

export interface ARCustomerRef {
  [key: string]: unknown;
  name: string;
  code?: string;
  status: string;
}

// ---------------------------------------------------------------------------
// Payroll Interfaces (referenced from Payroll module)
// ---------------------------------------------------------------------------

export interface PayRunRef {
  [key: string]: unknown;
  periodStart: string;
  periodEnd: string;
  payDate: string;
  status: string;
  totalGross: number;
  totalNet: number;
  totalTaxes: number;
  totalDeductions: number;
  employeeCount: number;
  entityId?: string;
}

export interface PayCheckRef {
  [key: string]: unknown;
  payRunId: string;
  employeeId: string;
  grossPay: number;
  federalTax: number;
  stateTax: number;
  localTax: number;
  ficaSS: number;
  ficaMed: number;
  totalDeductions: number;
  netPay: number;
  hours: number;
  overtimeHours: number;
}

export interface EmployeeRef {
  [key: string]: unknown;
  firstName: string;
  lastName: string;
  status: string;
  department?: string;
  payType: string;
  payRate: number;
  entityId?: string;
}

// ---------------------------------------------------------------------------
// Job Interfaces (referenced from Job module)
// ---------------------------------------------------------------------------

export interface JobRef {
  [key: string]: unknown;
  number: string;
  name: string;
  type: string;
  status: string;
  contractAmount: number;
  totalBudget: number;
  totalActualCost: number;
  totalCommitted: number;
  totalBilled: number;
  percentComplete: number;
  entityId?: string;
  retentionPct: number;
}

export interface ActualCostRef {
  [key: string]: unknown;
  jobId: string;
  costCodeId: string;
  costType: string;
  date: string;
  amount: number;
  description?: string;
  source: string;
}

export interface BudgetLineRef {
  [key: string]: unknown;
  budgetId: string;
  jobId: string;
  costCodeId: string;
  costType: string;
  amount: number;
}

export interface BudgetRef {
  [key: string]: unknown;
  jobId: string;
  name: string;
  status: string;
  totalAmount: number;
}

export interface CommittedCostRef {
  [key: string]: unknown;
  jobId: string;
  costCodeId: string;
  costType: string;
  amount: number;
  invoicedAmount: number;
  remainingAmount: number;
  status: string;
}

export interface ChangeOrderRef {
  [key: string]: unknown;
  jobId: string;
  number: string;
  description: string;
  amount: number;
  status: string;
}

export interface CostCodeRef {
  [key: string]: unknown;
  code: string;
  description: string;
}

// ---------------------------------------------------------------------------
// Equipment Interfaces (referenced from Equipment module if available)
// ---------------------------------------------------------------------------

export interface EquipmentRef {
  [key: string]: unknown;
  code: string;
  name: string;
  type?: string;
  status?: string;
  purchasePrice?: number;
  hourlyRate?: number;
  totalHours?: number;
  entityId?: string;
}

export interface EquipmentUsageRef {
  [key: string]: unknown;
  equipmentId: string;
  jobId?: string;
  date: string;
  hours: number;
  cost: number;
  description?: string;
}

// ---------------------------------------------------------------------------
// Report Configuration
// ---------------------------------------------------------------------------

export interface ReportConfig {
  [key: string]: unknown;
  reportType: ReportType;
  entityId?: string;
  periodStart: string;
  periodEnd: string;
  comparePeriodStart?: string;
  comparePeriodEnd?: string;
  jobId?: string;
  consolidated?: boolean;
  format?: ReportFormat;
  style?: string;
  method?: string;
}

// ---------------------------------------------------------------------------
// Report Output Interfaces
// ---------------------------------------------------------------------------

export interface BalanceSheetRow {
  [key: string]: unknown;
  accountId: string;
  accountNumber: string;
  accountName: string;
  accountType: string;
  currentBalance: number;
  priorBalance?: number;
  change?: number;
}

export interface IncomeStatementRow {
  [key: string]: unknown;
  accountId: string;
  accountNumber: string;
  accountName: string;
  category: IncomeCategory;
  currentAmount: number;
  priorAmount?: number;
  budget?: number;
  variance?: number;
}

export interface CashFlowRow {
  [key: string]: unknown;
  category: CashFlowCategory;
  description: string;
  amount: number;
}

export interface WipScheduleRow {
  [key: string]: unknown;
  jobId: string;
  jobNumber: string;
  jobName: string;
  contractAmount: number;
  totalBudget: number;
  actualCostToDate: number;
  estimateToComplete: number;
  estimateAtCompletion: number;
  percentComplete: number;
  earnedRevenue: number;
  billedToDate: number;
  overUnderBilling: number;
  projectedGrossProfit: number;
  projectedMarginPct: number;
}

export interface JobCostSummaryRow {
  [key: string]: unknown;
  jobId: string;
  jobNumber: string;
  jobName: string;
  contractAmount: number;
  approvedChangeOrders: number;
  revisedContract: number;
  totalBudget: number;
  actualCostToDate: number;
  committedCost: number;
  projectedCost: number;
  projectedProfit: number;
  projectedMarginPct: number;
  percentComplete: number;
}

export interface AgingReportRow {
  [key: string]: unknown;
  entityId: string;
  entityName: string;
  current: number;
  days30: number;
  days60: number;
  days90: number;
  days120Plus: number;
  total: number;
}

export interface PayrollSummaryRow {
  [key: string]: unknown;
  employeeId: string;
  employeeName: string;
  department?: string;
  totalGross: number;
  totalFederalTax: number;
  totalStateTax: number;
  totalLocalTax: number;
  totalFicaSS: number;
  totalFicaMed: number;
  totalDeductions: number;
  totalNet: number;
  totalHours: number;
  totalOvertimeHours: number;
}

export interface EquipmentUtilizationRow {
  [key: string]: unknown;
  equipmentId: string;
  equipmentCode: string;
  equipmentName: string;
  totalHours: number;
  totalCost: number;
  averageHourlyRate: number;
  utilizationPct: number;
  jobBreakdown: Array<{ jobId: string; hours: number; cost: number }>;
}

export interface EquipmentCostRow {
  [key: string]: unknown;
  equipmentId: string;
  equipmentCode: string;
  equipmentName: string;
  purchasePrice: number;
  totalOperatingCost: number;
  totalRevenue: number;
  netCost: number;
  costPerHour: number;
}

export interface BondingCapacityRow {
  [key: string]: unknown;
  totalAssets: number;
  totalLiabilities: number;
  netWorth: number;
  workingCapital: number;
  currentRatio: number;
  debtToEquity: number;
  backlog: number;
  aggregateBondingLimit: number;
  singleJobLimit: number;
  availableCapacity: number;
  currentBondedWork: number;
  wipAdjustment: number;
}

// ---------------------------------------------------------------------------
// Report Template
// ---------------------------------------------------------------------------

export interface ReportTemplate {
  [key: string]: unknown;
  name: string;
  reportType: ReportType;
  description?: string;
  columns: string[];
  filters: Array<{ field: string; operator: string; value: unknown }>;
  groupBy: string[];
  sortBy: Array<{ field: string; direction: 'asc' | 'desc' }>;
  isDefault?: boolean;
  createdBy?: string;
}

// ---------------------------------------------------------------------------
// Report Result Wrapper
// ---------------------------------------------------------------------------

export interface ReportResult {
  [key: string]: unknown;
  reportType: ReportType;
  title: string;
  generatedAt: string;
  periodStart: string;
  periodEnd: string;
  entityId?: string;
  consolidated: boolean;
  rows: unknown[];
  totals?: Record<string, number>;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Round a number to 2 decimal places. */
function round2(value: number): number {
  return Math.round(value * 100) / 100;
}

// ---------------------------------------------------------------------------
// ReportsService
// ---------------------------------------------------------------------------

export class ReportsService {
  constructor(
    private accounts: Collection<GLAccountRef>,
    private journalEntries: Collection<GLJournalEntryRef>,
    private journalLines: Collection<GLJournalLineRef>,
    _fiscalPeriods: Collection<GLFiscalPeriodRef>,
    private apInvoices: Collection<APInvoiceRef>,
    private apVendors: Collection<APVendorRef>,
    private arInvoices: Collection<ARInvoiceRef>,
    private arCustomers: Collection<ARCustomerRef>,
    private payRuns: Collection<PayRunRef>,
    private payChecks: Collection<PayCheckRef>,
    private employees: Collection<EmployeeRef>,
    private jobs: Collection<JobRef>,
    private actualCosts: Collection<ActualCostRef>,
    private budgets: Collection<BudgetRef>,
    _budgetLines: Collection<BudgetLineRef>,
    private committedCosts: Collection<CommittedCostRef>,
    private changeOrders: Collection<ChangeOrderRef>,
    _costCodes: Collection<CostCodeRef>,
    private templates: Collection<ReportTemplate>,
    private events: EventBus,
    private equipment?: Collection<EquipmentRef>,
    private equipmentUsage?: Collection<EquipmentUsageRef>,
  ) {}

  // ========================================================================
  // BALANCE SHEET
  // ========================================================================

  /**
   * Generate a balance sheet report.
   *
   * Aggregates all posted journal lines up to periodEnd for asset, liability,
   * and equity accounts. If comparePeriodEnd is provided, also computes
   * prior-period balances and change amounts.
   *
   * Supports styles: standard, comparative, consolidated.
   */
  async generateBalanceSheet(config: ReportConfig): Promise<BalanceSheetRow[]> {
    const { periodEnd, comparePeriodEnd } = config;

    // Get all accounts
    const allAccounts = await this.accounts
      .query()
      .orderBy('number', 'asc')
      .execute();

    // Filter to balance sheet accounts (asset, liability, equity)
    const bsAccounts = allAccounts.filter(
      (a) =>
        a.type === 'asset' || a.type === 'liability' || a.type === 'equity',
    );

    // Get current period balances
    const currentBalances = await this.getAccountBalancesAsOf(periodEnd);

    // Get prior period balances if comparative
    let priorBalances: Map<string, number> | undefined;
    if (comparePeriodEnd) {
      priorBalances = await this.getAccountBalancesAsOf(comparePeriodEnd);
    }

    const rows: BalanceSheetRow[] = [];

    for (const account of bsAccounts) {
      if (!account.isActive && !currentBalances.has(account.id)) {
        continue;
      }

      const currentBalance = currentBalances.get(account.id) ?? 0;
      const priorBalance = priorBalances ? (priorBalances.get(account.id) ?? 0) : undefined;
      const change = priorBalance !== undefined ? round2(currentBalance - priorBalance) : undefined;

      rows.push({
        accountId: account.id,
        accountNumber: account.number,
        accountName: account.name,
        accountType: account.type,
        currentBalance: round2(currentBalance),
        priorBalance: priorBalance !== undefined ? round2(priorBalance) : undefined,
        change,
      });
    }

    this.events.emit('reports.generated', {
      reportType: 'balance-sheet',
      rowCount: rows.length,
      periodEnd,
    });

    return rows;
  }

  // ========================================================================
  // INCOME STATEMENT
  // ========================================================================

  /**
   * Generate an income statement report.
   *
   * Aggregates posted journal lines within periodStart..periodEnd for
   * revenue, costOfRevenue, and expense accounts. Categorizes into
   * revenue, cogs, expense, and other.
   *
   * If comparePeriodStart/comparePeriodEnd is provided, computes prior
   * period amounts and variance.
   *
   * Supports styles: standard, by-job, by-entity, comparative.
   */
  async generateIncomeStatement(config: ReportConfig): Promise<IncomeStatementRow[]> {
    const { periodStart, periodEnd, comparePeriodStart, comparePeriodEnd } = config;

    // Get all accounts
    const allAccounts = await this.accounts
      .query()
      .orderBy('number', 'asc')
      .execute();

    // Filter to income statement accounts
    const isAccounts = allAccounts.filter(
      (a) =>
        a.type === 'revenue' ||
        a.type === 'costOfRevenue' ||
        a.type === 'expense',
    );

    // Get current period activity
    const currentActivity = await this.getAccountActivityForPeriod(periodStart, periodEnd);

    // Get prior period activity if comparative
    let priorActivity: Map<string, number> | undefined;
    if (comparePeriodStart && comparePeriodEnd) {
      priorActivity = await this.getAccountActivityForPeriod(
        comparePeriodStart,
        comparePeriodEnd,
      );
    }

    const rows: IncomeStatementRow[] = [];

    for (const account of isAccounts) {
      const currentAmount = currentActivity.get(account.id) ?? 0;
      const priorAmount = priorActivity
        ? (priorActivity.get(account.id) ?? 0)
        : undefined;

      // Skip inactive accounts with no activity
      if (!account.isActive && currentAmount === 0 && (priorAmount === undefined || priorAmount === 0)) {
        continue;
      }

      // Map account type to income category
      let category: IncomeCategory;
      switch (account.type) {
        case 'revenue':
          category = 'revenue';
          break;
        case 'costOfRevenue':
          category = 'cogs';
          break;
        case 'expense':
          category = 'expense';
          break;
        default:
          category = 'other';
      }

      const variance = priorAmount !== undefined
        ? round2(currentAmount - priorAmount)
        : undefined;

      rows.push({
        accountId: account.id,
        accountNumber: account.number,
        accountName: account.name,
        category,
        currentAmount: round2(currentAmount),
        priorAmount: priorAmount !== undefined ? round2(priorAmount) : undefined,
        budget: undefined,
        variance,
      });
    }

    this.events.emit('reports.generated', {
      reportType: 'income-statement',
      rowCount: rows.length,
      periodStart,
      periodEnd,
    });

    return rows;
  }

  // ========================================================================
  // CASH FLOW STATEMENT
  // ========================================================================

  /**
   * Generate a cash flow statement.
   *
   * Uses the indirect method by default: starts with net income (from
   * income statement activity), then adjusts for non-cash items and
   * changes in working capital.
   *
   * Direct method sums actual cash-related journal entries by category.
   *
   * Supports methods: direct, indirect.
   */
  async generateCashFlowStatement(config: ReportConfig): Promise<CashFlowRow[]> {
    const { periodStart, periodEnd, method } = config;
    const cashFlowMethod = (method as CashFlowMethod) || 'indirect';

    const rows: CashFlowRow[] = [];

    if (cashFlowMethod === 'indirect') {
      // Indirect Method: Start with net income, adjust for non-cash items

      // Step 1: Compute net income from income statement accounts
      const activity = await this.getAccountActivityForPeriod(periodStart, periodEnd);
      const allAccounts = await this.accounts.query().execute();
      const accountMap = new Map(allAccounts.map((a) => [a.id, a]));

      let totalRevenue = 0;
      let totalExpense = 0;

      for (const [accountId, amount] of activity) {
        const account = accountMap.get(accountId);
        if (!account) continue;

        if (account.type === 'revenue') {
          totalRevenue = round2(totalRevenue + amount);
        } else if (account.type === 'expense' || account.type === 'costOfRevenue') {
          totalExpense = round2(totalExpense + amount);
        }
      }

      const netIncome = round2(totalRevenue - totalExpense);

      rows.push({
        category: 'operating',
        description: 'Net Income',
        amount: netIncome,
      });

      // Step 2: Adjustments for changes in balance sheet accounts
      // Compute beginning and ending balances for current assets and liabilities
      const endBalances = await this.getAccountBalancesAsOf(periodEnd);
      const beginBalances = await this.getAccountBalancesAsOf(periodStart);

      let totalArChange = 0;
      let totalApChange = 0;
      let totalOtherCurrentAssetChange = 0;
      let totalOtherCurrentLiabilityChange = 0;

      for (const account of allAccounts) {
        if (account.type !== 'asset' && account.type !== 'liability') continue;

        const endBal = endBalances.get(account.id) ?? 0;
        const beginBal = beginBalances.get(account.id) ?? 0;
        const change = round2(endBal - beginBal);

        if (change === 0) continue;

        const nameUpper = account.name.toUpperCase();

        if (account.type === 'asset') {
          if (nameUpper.includes('RECEIVABLE') || nameUpper.includes('A/R') || nameUpper.includes('AR')) {
            totalArChange = round2(totalArChange + change);
          } else if (!nameUpper.includes('CASH') && !nameUpper.includes('BANK') && !nameUpper.includes('FIXED') && !nameUpper.includes('PROPERTY') && !nameUpper.includes('EQUIPMENT')) {
            totalOtherCurrentAssetChange = round2(totalOtherCurrentAssetChange + change);
          }
        } else if (account.type === 'liability') {
          if (nameUpper.includes('PAYABLE') || nameUpper.includes('A/P') || nameUpper.includes('AP')) {
            totalApChange = round2(totalApChange + change);
          } else {
            totalOtherCurrentLiabilityChange = round2(totalOtherCurrentLiabilityChange + change);
          }
        }
      }

      // Increase in AR = cash outflow (subtract); Increase in AP = cash inflow (add)
      if (totalArChange !== 0) {
        rows.push({
          category: 'operating',
          description: 'Change in Accounts Receivable',
          amount: round2(-totalArChange),
        });
      }

      if (totalApChange !== 0) {
        rows.push({
          category: 'operating',
          description: 'Change in Accounts Payable',
          amount: totalApChange,
        });
      }

      if (totalOtherCurrentAssetChange !== 0) {
        rows.push({
          category: 'operating',
          description: 'Change in Other Current Assets',
          amount: round2(-totalOtherCurrentAssetChange),
        });
      }

      if (totalOtherCurrentLiabilityChange !== 0) {
        rows.push({
          category: 'operating',
          description: 'Change in Other Current Liabilities',
          amount: totalOtherCurrentLiabilityChange,
        });
      }

      // Step 3: Investing activities - changes in fixed/long-term asset accounts
      let totalInvestingChange = 0;

      for (const account of allAccounts) {
        if (account.type !== 'asset') continue;
        const nameUpper = account.name.toUpperCase();
        if (nameUpper.includes('FIXED') || nameUpper.includes('PROPERTY') || nameUpper.includes('EQUIPMENT') || nameUpper.includes('INVESTMENT')) {
          const endBal = endBalances.get(account.id) ?? 0;
          const beginBal = beginBalances.get(account.id) ?? 0;
          const change = round2(endBal - beginBal);
          totalInvestingChange = round2(totalInvestingChange + change);
        }
      }

      if (totalInvestingChange !== 0) {
        rows.push({
          category: 'investing',
          description: 'Capital Expenditures / Investment Changes',
          amount: round2(-totalInvestingChange),
        });
      }

      // Step 4: Financing activities - changes in long-term liabilities and equity
      let totalFinancingChange = 0;

      for (const account of allAccounts) {
        if (account.type === 'equity') {
          const endBal = endBalances.get(account.id) ?? 0;
          const beginBal = beginBalances.get(account.id) ?? 0;
          const change = round2(endBal - beginBal);
          // Exclude retained earnings change from net income which is already counted
          const nameUpper = account.name.toUpperCase();
          if (!nameUpper.includes('RETAINED') && !nameUpper.includes('EARNINGS')) {
            totalFinancingChange = round2(totalFinancingChange + change);
          }
        }
      }

      if (totalFinancingChange !== 0) {
        rows.push({
          category: 'financing',
          description: 'Changes in Equity / Financing',
          amount: totalFinancingChange,
        });
      }
    } else {
      // Direct Method: Aggregate cash-related journal entries by category

      // Get posted journal entries within the period
      const entries = await this.journalEntries
        .query()
        .where('status', '=', 'posted')
        .where('date', '>=', periodStart)
        .where('date', '<=', periodEnd)
        .execute();

      const entryIds = entries.map((e) => e.id);

      if (entryIds.length > 0) {
        const lines = await this.journalLines
          .query()
          .where('journalEntryId', 'in', entryIds)
          .execute();

        const allAccounts = await this.accounts.query().execute();
        const accountMap = new Map(allAccounts.map((a) => [a.id, a]));

        // Identify cash/bank accounts
        const cashAccountIds = new Set<string>();
        for (const account of allAccounts) {
          const nameUpper = account.name.toUpperCase();
          if (nameUpper.includes('CASH') || nameUpper.includes('BANK') || nameUpper.includes('CHECKING') || nameUpper.includes('SAVINGS')) {
            cashAccountIds.add(account.id);
          }
        }

        // Find all journal entries that touch a cash account
        const cashEntryIds = new Set<string>();
        for (const line of lines) {
          if (cashAccountIds.has(line.accountId)) {
            cashEntryIds.add(line.journalEntryId);
          }
        }

        // For each cash-touching entry, categorize the non-cash side
        let operatingTotal = 0;
        let investingTotal = 0;
        let financingTotal = 0;

        for (const line of lines) {
          if (!cashEntryIds.has(line.journalEntryId)) continue;
          if (cashAccountIds.has(line.accountId)) continue;

          const account = accountMap.get(line.accountId);
          if (!account) continue;

          const netAmount = round2((line.credit || 0) - (line.debit || 0));
          const nameUpper = account.name.toUpperCase();

          if (account.type === 'revenue' || account.type === 'expense' || account.type === 'costOfRevenue') {
            operatingTotal = round2(operatingTotal + netAmount);
          } else if (nameUpper.includes('FIXED') || nameUpper.includes('PROPERTY') || nameUpper.includes('EQUIPMENT') || nameUpper.includes('INVESTMENT')) {
            investingTotal = round2(investingTotal + netAmount);
          } else if (account.type === 'equity' || nameUpper.includes('LOAN') || nameUpper.includes('NOTE') || nameUpper.includes('MORTGAGE')) {
            financingTotal = round2(financingTotal + netAmount);
          } else {
            operatingTotal = round2(operatingTotal + netAmount);
          }
        }

        if (operatingTotal !== 0) {
          rows.push({
            category: 'operating',
            description: 'Cash from Operating Activities',
            amount: operatingTotal,
          });
        }

        if (investingTotal !== 0) {
          rows.push({
            category: 'investing',
            description: 'Cash from Investing Activities',
            amount: investingTotal,
          });
        }

        if (financingTotal !== 0) {
          rows.push({
            category: 'financing',
            description: 'Cash from Financing Activities',
            amount: financingTotal,
          });
        }
      }
    }

    this.events.emit('reports.generated', {
      reportType: 'cash-flow',
      rowCount: rows.length,
      periodStart,
      periodEnd,
      method: cashFlowMethod,
    });

    return rows;
  }

  // ========================================================================
  // WIP SCHEDULE
  // ========================================================================

  /**
   * Generate a WIP (Work In Progress) schedule for all active jobs
   * or a specific job.
   *
   * Uses cost-to-cost percentage-of-completion method by default.
   * Supports methods: cost, units, efforts.
   *
   * Computes earned revenue, over/under billing, projected profit,
   * and projected margin for each job.
   */
  async generateWipSchedule(config: ReportConfig): Promise<WipScheduleRow[]> {
    const { jobId } = config;

    // Get jobs (either specific or all active)
    let jobsList: (JobRef & CollectionMeta)[];
    if (jobId) {
      const job = await this.jobs.get(jobId);
      if (!job) {
        throw new Error(`Job not found: ${jobId}`);
      }
      jobsList = [job];
    } else {
      jobsList = await this.jobs
        .query()
        .where('status', '=', 'active')
        .orderBy('number', 'asc')
        .execute();
    }

    const rows: WipScheduleRow[] = [];

    for (const job of jobsList) {
      // Get approved change orders
      const approvedCOs = await this.changeOrders
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const coTotal = approvedCOs.reduce((sum, co) => sum + (co.amount || 0), 0);
      const contractAmount = round2(job.contractAmount + coTotal);

      // Get actual costs
      const costs = await this.actualCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const actualCostToDate = round2(
        costs.reduce((sum, c) => sum + (c.amount || 0), 0),
      );

      // Get approved budgets total
      const approvedBudgets = await this.budgets
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const totalBudget = round2(
        approvedBudgets.reduce((sum, b) => sum + (b.totalAmount || 0), 0),
      );

      // Get committed costs (remaining on open/partial)
      const committed = await this.committedCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const committedRemaining = round2(
        committed
          .filter((c) => c.status !== 'cancelled')
          .reduce((sum, c) => sum + (c.remainingAmount || 0), 0),
      );

      // Estimate at completion
      const remainingBudget = Math.max(totalBudget - actualCostToDate - committedRemaining, 0);
      const estimateAtCompletion = round2(actualCostToDate + committedRemaining + remainingBudget);
      const estimateToComplete = round2(estimateAtCompletion - actualCostToDate);

      // Percent complete (cost-to-cost)
      const percentComplete = estimateAtCompletion > 0
        ? round2((actualCostToDate / estimateAtCompletion) * 100)
        : 0;

      // Earned revenue
      const earnedRevenue = round2((percentComplete / 100) * contractAmount);

      // Billed to date
      const billedToDate = job.totalBilled || 0;

      // Over/under billing (positive = underbilled, negative = overbilled)
      const overUnderBilling = round2(earnedRevenue - billedToDate);

      // Projected gross profit and margin
      const projectedGrossProfit = round2(contractAmount - estimateAtCompletion);
      const projectedMarginPct = contractAmount !== 0
        ? round2((projectedGrossProfit / contractAmount) * 100)
        : 0;

      rows.push({
        jobId: job.id,
        jobNumber: job.number,
        jobName: job.name,
        contractAmount,
        totalBudget,
        actualCostToDate,
        estimateToComplete,
        estimateAtCompletion,
        percentComplete,
        earnedRevenue,
        billedToDate,
        overUnderBilling,
        projectedGrossProfit,
        projectedMarginPct,
      });
    }

    this.events.emit('reports.generated', {
      reportType: 'wip-schedule',
      rowCount: rows.length,
    });

    return rows;
  }

  // ========================================================================
  // JOB COST SUMMARY
  // ========================================================================

  /**
   * Generate a job cost summary report for a specific job or all active jobs.
   *
   * Computes contract + approved change orders = revised contract,
   * projected costs (actual + committed remaining + ETC for remaining budget),
   * projected profit and margin percentage.
   */
  async generateJobCostSummary(jobId?: string): Promise<JobCostSummaryRow[]> {
    let jobsList: (JobRef & CollectionMeta)[];
    if (jobId) {
      const job = await this.jobs.get(jobId);
      if (!job) {
        throw new Error(`Job not found: ${jobId}`);
      }
      jobsList = [job];
    } else {
      jobsList = await this.jobs
        .query()
        .where('status', '=', 'active')
        .orderBy('number', 'asc')
        .execute();
    }

    const rows: JobCostSummaryRow[] = [];

    for (const job of jobsList) {
      // Get approved change orders
      const approvedCOs = await this.changeOrders
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const approvedChangeOrders = round2(
        approvedCOs.reduce((sum, co) => sum + (co.amount || 0), 0),
      );
      const revisedContract = round2(job.contractAmount + approvedChangeOrders);

      // Get actual costs
      const costs = await this.actualCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const actualCostToDate = round2(
        costs.reduce((sum, c) => sum + (c.amount || 0), 0),
      );

      // Get committed costs (remaining)
      const committed = await this.committedCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const committedCost = round2(
        committed
          .filter((c) => c.status !== 'cancelled')
          .reduce((sum, c) => sum + (c.remainingAmount || 0), 0),
      );

      // Get approved budget total
      const approvedBudgets = await this.budgets
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const totalBudget = round2(
        approvedBudgets.reduce((sum, b) => sum + (b.totalAmount || 0), 0),
      );

      // Projected cost
      const remainingBudget = Math.max(totalBudget - actualCostToDate - committedCost, 0);
      const projectedCost = round2(actualCostToDate + committedCost + remainingBudget);

      const projectedProfit = round2(revisedContract - projectedCost);
      const projectedMarginPct = revisedContract !== 0
        ? round2((projectedProfit / revisedContract) * 100)
        : 0;

      rows.push({
        jobId: job.id,
        jobNumber: job.number,
        jobName: job.name,
        contractAmount: job.contractAmount,
        approvedChangeOrders,
        revisedContract,
        totalBudget,
        actualCostToDate,
        committedCost,
        projectedCost,
        projectedProfit,
        projectedMarginPct,
        percentComplete: job.percentComplete,
      });
    }

    this.events.emit('reports.generated', {
      reportType: 'job-cost-summary',
      rowCount: rows.length,
    });

    return rows;
  }

  // ========================================================================
  // AGING REPORTS (AP & AR)
  // ========================================================================

  /**
   * Generate an aging report for accounts payable or accounts receivable.
   *
   * For AP: groups open AP invoices by vendor into aging buckets.
   * For AR: groups open AR invoices by customer into aging buckets.
   *
   * Buckets: Current (0-30), 31-60, 61-90, 91-120, 120+.
   */
  async generateAgingReport(type: 'ap' | 'ar', asOfDate: string): Promise<AgingReportRow[]> {
    const asOf = new Date(asOfDate);
    const asOfTime = asOf.getTime();

    if (type === 'ap') {
      return this.generateAPAging(asOfTime);
    } else {
      return this.generateARAging(asOfTime);
    }
  }

  /**
   * Generate AP aging report.
   */
  private async generateAPAging(asOfTime: number): Promise<AgingReportRow[]> {
    const allInvoices = await this.apInvoices.query().execute();
    const openInvoices = allInvoices.filter(
      (inv) => inv.status !== 'paid' && inv.status !== 'voided',
    );

    const vendorMap = new Map<
      string,
      { current: number; days30: number; days60: number; days90: number; days120Plus: number; total: number }
    >();

    for (const inv of openInvoices) {
      const referenceDate = inv.dueDate || inv.invoiceDate;
      const refTime = new Date(referenceDate).getTime();
      const daysOld = Math.floor((asOfTime - refTime) / (1000 * 60 * 60 * 24));
      const balance = inv.balanceDue;

      if (!vendorMap.has(inv.vendorId)) {
        vendorMap.set(inv.vendorId, {
          current: 0,
          days30: 0,
          days60: 0,
          days90: 0,
          days120Plus: 0,
          total: 0,
        });
      }

      const bucket = vendorMap.get(inv.vendorId)!;

      if (daysOld <= 30) {
        bucket.current = round2(bucket.current + balance);
      } else if (daysOld <= 60) {
        bucket.days30 = round2(bucket.days30 + balance);
      } else if (daysOld <= 90) {
        bucket.days60 = round2(bucket.days60 + balance);
      } else if (daysOld <= 120) {
        bucket.days90 = round2(bucket.days90 + balance);
      } else {
        bucket.days120Plus = round2(bucket.days120Plus + balance);
      }

      bucket.total = round2(bucket.total + balance);
    }

    const rows: AgingReportRow[] = [];

    for (const [vendorId, bucket] of vendorMap) {
      const vendor = await this.apVendors.get(vendorId);
      const vendorName = vendor ? vendor.name : vendorId;

      rows.push({
        entityId: vendorId,
        entityName: vendorName,
        current: bucket.current,
        days30: bucket.days30,
        days60: bucket.days60,
        days90: bucket.days90,
        days120Plus: bucket.days120Plus,
        total: bucket.total,
      });
    }

    rows.sort((a, b) => a.entityName.localeCompare(b.entityName));

    this.events.emit('reports.generated', {
      reportType: 'aging-ap',
      rowCount: rows.length,
    });

    return rows;
  }

  /**
   * Generate AR aging report.
   */
  private async generateARAging(asOfTime: number): Promise<AgingReportRow[]> {
    const allInvoices = await this.arInvoices.query().execute();
    const openInvoices = allInvoices.filter(
      (inv) => inv.status !== 'paid' && inv.status !== 'voided',
    );

    const customerMap = new Map<
      string,
      { current: number; days30: number; days60: number; days90: number; days120Plus: number; total: number }
    >();

    for (const inv of openInvoices) {
      const referenceDate = inv.dueDate || inv.invoiceDate;
      const refTime = new Date(referenceDate).getTime();
      const daysOld = Math.floor((asOfTime - refTime) / (1000 * 60 * 60 * 24));
      const balance = inv.balanceDue;

      if (!customerMap.has(inv.customerId)) {
        customerMap.set(inv.customerId, {
          current: 0,
          days30: 0,
          days60: 0,
          days90: 0,
          days120Plus: 0,
          total: 0,
        });
      }

      const bucket = customerMap.get(inv.customerId)!;

      if (daysOld <= 30) {
        bucket.current = round2(bucket.current + balance);
      } else if (daysOld <= 60) {
        bucket.days30 = round2(bucket.days30 + balance);
      } else if (daysOld <= 90) {
        bucket.days60 = round2(bucket.days60 + balance);
      } else if (daysOld <= 120) {
        bucket.days90 = round2(bucket.days90 + balance);
      } else {
        bucket.days120Plus = round2(bucket.days120Plus + balance);
      }

      bucket.total = round2(bucket.total + balance);
    }

    const rows: AgingReportRow[] = [];

    for (const [customerId, bucket] of customerMap) {
      const customer = await this.arCustomers.get(customerId);
      const customerName = customer ? customer.name : customerId;

      rows.push({
        entityId: customerId,
        entityName: customerName,
        current: bucket.current,
        days30: bucket.days30,
        days60: bucket.days60,
        days90: bucket.days90,
        days120Plus: bucket.days120Plus,
        total: bucket.total,
      });
    }

    rows.sort((a, b) => a.entityName.localeCompare(b.entityName));

    this.events.emit('reports.generated', {
      reportType: 'aging-ar',
      rowCount: rows.length,
    });

    return rows;
  }

  // ========================================================================
  // PAYROLL SUMMARY
  // ========================================================================

  /**
   * Generate a payroll summary report for a date range.
   *
   * Aggregates all completed pay runs within the period,
   * then sums all pay checks for each employee.
   */
  async generatePayrollSummary(
    periodStart: string,
    periodEnd: string,
  ): Promise<PayrollSummaryRow[]> {
    // Get completed pay runs in the period
    const allRuns = await this.payRuns
      .query()
      .where('status', '=', 'completed')
      .where('payDate', '>=', periodStart)
      .where('payDate', '<=', periodEnd)
      .execute();

    // Aggregate by employee
    const employeeAgg = new Map<
      string,
      {
        totalGross: number;
        totalFederalTax: number;
        totalStateTax: number;
        totalLocalTax: number;
        totalFicaSS: number;
        totalFicaMed: number;
        totalDeductions: number;
        totalNet: number;
        totalHours: number;
        totalOvertimeHours: number;
      }
    >();

    for (const run of allRuns) {
      const checks = await this.payChecks
        .query()
        .where('payRunId', '=', run.id)
        .execute();

      for (const check of checks) {
        if (!employeeAgg.has(check.employeeId)) {
          employeeAgg.set(check.employeeId, {
            totalGross: 0,
            totalFederalTax: 0,
            totalStateTax: 0,
            totalLocalTax: 0,
            totalFicaSS: 0,
            totalFicaMed: 0,
            totalDeductions: 0,
            totalNet: 0,
            totalHours: 0,
            totalOvertimeHours: 0,
          });
        }

        const agg = employeeAgg.get(check.employeeId)!;
        agg.totalGross = round2(agg.totalGross + check.grossPay);
        agg.totalFederalTax = round2(agg.totalFederalTax + check.federalTax);
        agg.totalStateTax = round2(agg.totalStateTax + check.stateTax);
        agg.totalLocalTax = round2(agg.totalLocalTax + check.localTax);
        agg.totalFicaSS = round2(agg.totalFicaSS + check.ficaSS);
        agg.totalFicaMed = round2(agg.totalFicaMed + check.ficaMed);
        agg.totalDeductions = round2(agg.totalDeductions + check.totalDeductions);
        agg.totalNet = round2(agg.totalNet + check.netPay);
        agg.totalHours = round2(agg.totalHours + check.hours);
        agg.totalOvertimeHours = round2(agg.totalOvertimeHours + check.overtimeHours);
      }
    }

    const rows: PayrollSummaryRow[] = [];

    for (const [employeeId, agg] of employeeAgg) {
      const employee = await this.employees.get(employeeId);
      const employeeName = employee
        ? `${employee.lastName}, ${employee.firstName}`
        : employeeId;
      const department = employee ? employee.department : undefined;

      rows.push({
        employeeId,
        employeeName,
        department,
        totalGross: agg.totalGross,
        totalFederalTax: agg.totalFederalTax,
        totalStateTax: agg.totalStateTax,
        totalLocalTax: agg.totalLocalTax,
        totalFicaSS: agg.totalFicaSS,
        totalFicaMed: agg.totalFicaMed,
        totalDeductions: agg.totalDeductions,
        totalNet: agg.totalNet,
        totalHours: agg.totalHours,
        totalOvertimeHours: agg.totalOvertimeHours,
      });
    }

    rows.sort((a, b) => a.employeeName.localeCompare(b.employeeName));

    this.events.emit('reports.generated', {
      reportType: 'payroll-summary',
      rowCount: rows.length,
      periodStart,
      periodEnd,
    });

    return rows;
  }

  // ========================================================================
  // EQUIPMENT UTILIZATION & COST
  // ========================================================================

  /**
   * Generate an equipment utilization report.
   *
   * Aggregates usage hours and costs by equipment item,
   * with job-level breakdown and utilization percentage
   * based on available hours in the period.
   */
  async generateEquipmentUtilization(
    periodStart: string,
    periodEnd: string,
  ): Promise<EquipmentUtilizationRow[]> {
    if (!this.equipment || !this.equipmentUsage) {
      return [];
    }

    const allEquipment = await this.equipment.query().execute();
    const allUsage = await this.equipmentUsage
      .query()
      .where('date', '>=', periodStart)
      .where('date', '<=', periodEnd)
      .execute();

    // Calculate available hours in the period (working days * 8 hours)
    const startDate = new Date(periodStart);
    const endDate = new Date(periodEnd);
    const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    const workingDays = Math.ceil(daysDiff * 5 / 7);
    const availableHours = workingDays * 8;

    // Aggregate by equipment
    const equipmentMap = new Map<
      string,
      {
        totalHours: number;
        totalCost: number;
        jobBreakdown: Map<string, { hours: number; cost: number }>;
      }
    >();

    for (const usage of allUsage) {
      if (!equipmentMap.has(usage.equipmentId)) {
        equipmentMap.set(usage.equipmentId, {
          totalHours: 0,
          totalCost: 0,
          jobBreakdown: new Map(),
        });
      }

      const entry = equipmentMap.get(usage.equipmentId)!;
      entry.totalHours = round2(entry.totalHours + usage.hours);
      entry.totalCost = round2(entry.totalCost + usage.cost);

      if (usage.jobId) {
        const jobEntry = entry.jobBreakdown.get(usage.jobId) ?? { hours: 0, cost: 0 };
        jobEntry.hours = round2(jobEntry.hours + usage.hours);
        jobEntry.cost = round2(jobEntry.cost + usage.cost);
        entry.jobBreakdown.set(usage.jobId, jobEntry);
      }
    }

    const equipMap = new Map(allEquipment.map((e) => [e.id, e]));
    const rows: EquipmentUtilizationRow[] = [];

    for (const [equipmentId, data] of equipmentMap) {
      const equip = equipMap.get(equipmentId);
      const code = equip ? equip.code : equipmentId;
      const name = equip ? equip.name : equipmentId;

      const utilizationPct = availableHours > 0
        ? round2((data.totalHours / availableHours) * 100)
        : 0;

      const averageHourlyRate = data.totalHours > 0
        ? round2(data.totalCost / data.totalHours)
        : 0;

      const jobBreakdown: Array<{ jobId: string; hours: number; cost: number }> = [];
      for (const [jobId, jobData] of data.jobBreakdown) {
        jobBreakdown.push({ jobId, hours: jobData.hours, cost: jobData.cost });
      }

      rows.push({
        equipmentId,
        equipmentCode: code,
        equipmentName: name,
        totalHours: data.totalHours,
        totalCost: data.totalCost,
        averageHourlyRate,
        utilizationPct,
        jobBreakdown,
      });
    }

    rows.sort((a, b) => a.equipmentCode.localeCompare(b.equipmentCode));

    this.events.emit('reports.generated', {
      reportType: 'equipment-utilization',
      rowCount: rows.length,
      periodStart,
      periodEnd,
    });

    return rows;
  }

  // ========================================================================
  // BONDING CAPACITY ANALYSIS
  // ========================================================================

  /**
   * Generate a bonding capacity analysis report for surety purposes.
   *
   * Computes:
   * - Total assets and liabilities from the balance sheet
   * - Net worth (assets - liabilities)
   * - Working capital (current assets - current liabilities)
   * - Current ratio and debt-to-equity ratio
   * - Backlog (total contract value of active jobs minus billed to date)
   * - Estimated aggregate and single job bonding limits
   * - Available bonding capacity
   * - WIP adjustment based on over/under billing
   *
   * Bonding limits are estimated using industry-standard multipliers:
   * - Aggregate limit: 10x working capital (conservative)
   * - Single job limit: aggregate / 3
   */
  async generateBondingCapacity(): Promise<BondingCapacityRow> {
    // Get all account balances for balance sheet computation
    const allAccounts = await this.accounts.query().execute();
    const accountMap = new Map(allAccounts.map((a) => [a.id, a]));

    // Get latest balances
    const balances = await this.getAccountBalancesAsOf(
      new Date().toISOString().split('T')[0],
    );

    let totalAssets = 0;
    let totalLiabilities = 0;
    let currentAssets = 0;
    let currentLiabilities = 0;

    for (const [accountId, balance] of balances) {
      const account = accountMap.get(accountId);
      if (!account) continue;

      if (account.type === 'asset') {
        totalAssets = round2(totalAssets + balance);
        const nameUpper = account.name.toUpperCase();
        // Current assets exclude fixed assets, property, equipment, long-term investments
        if (
          !nameUpper.includes('FIXED') &&
          !nameUpper.includes('PROPERTY') &&
          !nameUpper.includes('EQUIPMENT') &&
          !nameUpper.includes('LONG-TERM') &&
          !nameUpper.includes('LONG TERM')
        ) {
          currentAssets = round2(currentAssets + balance);
        }
      } else if (account.type === 'liability') {
        totalLiabilities = round2(totalLiabilities + balance);
        const nameUpper = account.name.toUpperCase();
        // Current liabilities exclude long-term debt
        if (
          !nameUpper.includes('LONG-TERM') &&
          !nameUpper.includes('LONG TERM') &&
          !nameUpper.includes('MORTGAGE') &&
          !nameUpper.includes('NOTE PAYABLE')
        ) {
          currentLiabilities = round2(currentLiabilities + balance);
        }
      }
    }

    const netWorth = round2(totalAssets - totalLiabilities);
    const workingCapital = round2(currentAssets - currentLiabilities);
    const currentRatio = currentLiabilities !== 0
      ? round2(currentAssets / currentLiabilities)
      : 0;
    const debtToEquity = netWorth !== 0
      ? round2(totalLiabilities / netWorth)
      : 0;

    // Compute backlog from active jobs
    const activeJobs = await this.jobs
      .query()
      .where('status', '=', 'active')
      .execute();

    let backlog = 0;
    let currentBondedWork = 0;
    let wipAdjustment = 0;

    for (const job of activeJobs) {
      // Get approved change orders for revised contract
      const approvedCOs = await this.changeOrders
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const coTotal = approvedCOs.reduce((sum, co) => sum + (co.amount || 0), 0);
      const revisedContract = round2(job.contractAmount + coTotal);
      const billedToDate = job.totalBilled || 0;

      backlog = round2(backlog + Math.max(revisedContract - billedToDate, 0));
      currentBondedWork = round2(currentBondedWork + revisedContract);

      // WIP adjustment: earned revenue minus billed (positive = underbilled)
      const actualCosts = await this.actualCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const actualCostToDate = actualCosts.reduce((sum, c) => sum + (c.amount || 0), 0);

      const approvedBudgets = await this.budgets
        .query()
        .where('jobId', '=', job.id)
        .where('status', '=', 'approved')
        .execute();

      const totalBudget = approvedBudgets.reduce((sum, b) => sum + (b.totalAmount || 0), 0);

      const committed = await this.committedCosts
        .query()
        .where('jobId', '=', job.id)
        .execute();

      const committedRemaining = committed
        .filter((c) => c.status !== 'cancelled')
        .reduce((sum, c) => sum + (c.remainingAmount || 0), 0);

      const remainingBudget = Math.max(totalBudget - actualCostToDate - committedRemaining, 0);
      const eac = actualCostToDate + committedRemaining + remainingBudget;
      const pctComplete = eac > 0 ? actualCostToDate / eac : 0;
      const earnedRevenue = pctComplete * revisedContract;

      wipAdjustment = round2(wipAdjustment + (earnedRevenue - billedToDate));
    }

    // Bonding capacity estimates (industry standard multipliers)
    const aggregateBondingLimit = round2(workingCapital * 10);
    const singleJobLimit = round2(aggregateBondingLimit / 3);
    const availableCapacity = round2(aggregateBondingLimit - currentBondedWork);

    const result: BondingCapacityRow = {
      totalAssets,
      totalLiabilities,
      netWorth,
      workingCapital,
      currentRatio,
      debtToEquity,
      backlog,
      aggregateBondingLimit,
      singleJobLimit,
      availableCapacity,
      currentBondedWork,
      wipAdjustment: round2(wipAdjustment),
    };

    this.events.emit('reports.generated', {
      reportType: 'bonding-capacity',
    });

    return result;
  }

  // ========================================================================
  // REPORT TEMPLATES CRUD
  // ========================================================================

  /**
   * Create a new report template.
   */
  async createTemplate(data: {
    name: string;
    reportType: ReportType;
    description?: string;
    columns: string[];
    filters: Array<{ field: string; operator: string; value: unknown }>;
    groupBy: string[];
    sortBy: Array<{ field: string; direction: 'asc' | 'desc' }>;
    isDefault?: boolean;
    createdBy?: string;
  }): Promise<ReportTemplate & CollectionMeta> {
    const record = await this.templates.insert({
      name: data.name,
      reportType: data.reportType,
      description: data.description,
      columns: data.columns,
      filters: data.filters,
      groupBy: data.groupBy,
      sortBy: data.sortBy,
      isDefault: data.isDefault ?? false,
      createdBy: data.createdBy,
    } as ReportTemplate);

    this.events.emit('reports.template.created', { template: record });
    return record;
  }

  /**
   * Update an existing report template.
   */
  async updateTemplate(
    id: string,
    changes: Partial<ReportTemplate>,
  ): Promise<ReportTemplate & CollectionMeta> {
    const existing = await this.templates.get(id);
    if (!existing) {
      throw new Error(`Report template not found: ${id}`);
    }

    const updated = await this.templates.update(id, changes as Partial<ReportTemplate>);
    return updated;
  }

  /**
   * Get all report templates, optionally filtered by report type.
   */
  async getTemplates(reportType?: ReportType): Promise<(ReportTemplate & CollectionMeta)[]> {
    const q = this.templates.query();

    if (reportType) {
      q.where('reportType', '=', reportType);
    }

    q.orderBy('name', 'asc');
    return q.execute();
  }

  /**
   * Get a single report template by ID.
   */
  async getTemplate(id: string): Promise<(ReportTemplate & CollectionMeta) | null> {
    return this.templates.get(id);
  }

  /**
   * Delete a report template.
   */
  async deleteTemplate(id: string): Promise<void> {
    const existing = await this.templates.get(id);
    if (!existing) {
      throw new Error(`Report template not found: ${id}`);
    }

    await this.templates.remove(id);
  }

  // ========================================================================
  // PRIVATE HELPERS
  // ========================================================================

  /**
   * Get account balances as of a given date.
   *
   * Sums all posted journal lines up to the given date, grouped by account.
   * Returns the net balance per account respecting normal balance direction:
   * - Debit-normal accounts: balance = debits - credits
   * - Credit-normal accounts: balance = credits - debits
   */
  private async getAccountBalancesAsOf(asOfDate: string): Promise<Map<string, number>> {
    const balances = new Map<string, number>();

    // Get posted journal entries up to asOfDate
    const entries = await this.journalEntries
      .query()
      .where('status', '=', 'posted')
      .where('date', '<=', asOfDate)
      .execute();

    const entryIds = entries.map((e) => e.id);

    if (entryIds.length === 0) {
      return balances;
    }

    // Get all lines for those entries
    const lines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .execute();

    // Get all accounts for normal balance direction
    const allAccounts = await this.accounts.query().execute();
    const accountMap = new Map(allAccounts.map((a) => [a.id, a]));

    // Aggregate
    const rawBalances = new Map<string, { debit: number; credit: number }>();

    for (const line of lines) {
      const current = rawBalances.get(line.accountId) || { debit: 0, credit: 0 };
      current.debit += line.debit || 0;
      current.credit += line.credit || 0;
      rawBalances.set(line.accountId, current);
    }

    // Compute net balance respecting normal balance direction
    for (const [accountId, raw] of rawBalances) {
      const account = accountMap.get(accountId);
      if (!account) continue;

      const isDebitNormal = account.normalBalance === 'debit';
      const balance = isDebitNormal
        ? round2(raw.debit - raw.credit)
        : round2(raw.credit - raw.debit);

      balances.set(accountId, balance);
    }

    return balances;
  }

  /**
   * Get account activity (net amounts) for a specific period.
   *
   * Sums posted journal lines within periodStart..periodEnd, grouped
   * by account. Returns the net activity (debits - credits) for
   * debit-normal accounts, and (credits - debits) for credit-normal.
   */
  private async getAccountActivityForPeriod(
    periodStart: string,
    periodEnd: string,
  ): Promise<Map<string, number>> {
    const activity = new Map<string, number>();

    // Get posted journal entries in the period
    const entries = await this.journalEntries
      .query()
      .where('status', '=', 'posted')
      .where('date', '>=', periodStart)
      .where('date', '<=', periodEnd)
      .execute();

    const entryIds = entries.map((e) => e.id);

    if (entryIds.length === 0) {
      return activity;
    }

    // Get all lines for those entries
    const lines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .execute();

    // Get all accounts for normal balance direction
    const allAccounts = await this.accounts.query().execute();
    const accountMap = new Map(allAccounts.map((a) => [a.id, a]));

    // Aggregate
    const rawActivity = new Map<string, { debit: number; credit: number }>();

    for (const line of lines) {
      const current = rawActivity.get(line.accountId) || { debit: 0, credit: 0 };
      current.debit += line.debit || 0;
      current.credit += line.credit || 0;
      rawActivity.set(line.accountId, current);
    }

    // Compute net activity respecting normal balance direction
    for (const [accountId, raw] of rawActivity) {
      const account = accountMap.get(accountId);
      if (!account) continue;

      const isDebitNormal = account.normalBalance === 'debit';
      const netActivity = isDebitNormal
        ? round2(raw.debit - raw.credit)
        : round2(raw.credit - raw.debit);

      activity.set(accountId, netActivity);
    }

    return activity;
  }
}
