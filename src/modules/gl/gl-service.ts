/**
 * Concrete -- GL Service (General Ledger Business Logic)
 *
 * Core service layer for the General Ledger module. Provides account management,
 * journal entry CRUD with double-entry enforcement, fiscal period management,
 * recurring entries, closing entries, and reporting (trial balance, GL detail).
 */

import type { Collection, CollectionMeta } from '../../core/store/collection';
import type { EventBus } from '../../core/events/bus';
import { now } from '../../core/types/base';

// ---------------------------------------------------------------------------
// Account Types
// ---------------------------------------------------------------------------

export type AccountType = 'asset' | 'liability' | 'equity' | 'revenue' | 'expense' | 'costOfRevenue';
export type NormalBalance = 'debit' | 'credit';

export interface GLAccount {
  [key: string]: unknown;
  number: string;
  name: string;
  type: AccountType;
  normalBalance: NormalBalance;
  parentId?: string;
  description?: string;
  isActive: boolean;
  depth: number;
  path: string;
  isSummary: boolean;
}

// ---------------------------------------------------------------------------
// Journal Entry Types
// ---------------------------------------------------------------------------

export interface GLJournalEntry {
  [key: string]: unknown;
  entryNumber: string;
  date: string;
  reference?: string;
  description?: string;
  status: 'draft' | 'posted' | 'voided';
  totalDebit: number;
  totalCredit: number;
  postedAt?: string;
  voidedAt?: string;
  voidReason?: string;
  sourceModule?: string;
  sourceId?: string;
  fiscalPeriodId?: string;
  isAutoGenerated: boolean;
}

export interface GLJournalLine {
  [key: string]: unknown;
  journalEntryId: string;
  accountId: string;
  accountNumber?: string;
  accountName?: string;
  debit: number;
  credit: number;
  description?: string;
  lineOrder: number;
}

// ---------------------------------------------------------------------------
// Fiscal Period Types
// ---------------------------------------------------------------------------

export interface GLFiscalPeriod {
  [key: string]: unknown;
  name: string;
  year: number;
  month?: number;
  startDate: string;
  endDate: string;
  status: 'open' | 'closed' | 'locked';
  closedAt?: string;
}

// ---------------------------------------------------------------------------
// Recurring Entry Types
// ---------------------------------------------------------------------------

export interface GLRecurringEntry {
  [key: string]: unknown;
  name: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
  isActive: boolean;
  nextRunDate?: string;
  lastRunDate?: string;
  endDate?: string;
  templateLines: Array<{ accountId: string; debit: number; credit: number; description?: string }>;
  runCount: number;
}

// ---------------------------------------------------------------------------
// Closing Entry Types
// ---------------------------------------------------------------------------

export interface GLClosingEntry {
  [key: string]: unknown;
  fiscalPeriodId: string;
  journalEntryId: string;
  type: 'income-summary' | 'retained-earnings';
  periodName?: string;
  totalAmount?: number;
}

// ---------------------------------------------------------------------------
// Tree Node & Report Types
// ---------------------------------------------------------------------------

export interface AccountTreeNode {
  account: GLAccount & { id: string };
  children: AccountTreeNode[];
}

export interface TrialBalanceRow {
  accountId: string;
  accountNumber: string;
  accountName: string;
  accountType: AccountType;
  debit: number;
  credit: number;
}

export interface GLDetailRow {
  date: string;
  entryNumber: string;
  journalEntryId: string;
  description: string;
  debit: number;
  credit: number;
  balance: number;
}

// ---------------------------------------------------------------------------
// GLService
// ---------------------------------------------------------------------------

export class GLService {
  constructor(
    private accounts: Collection<GLAccount>,
    private journalEntries: Collection<GLJournalEntry>,
    private journalLines: Collection<GLJournalLine>,
    private fiscalPeriods: Collection<GLFiscalPeriod>,
    private recurringEntries: Collection<GLRecurringEntry>,
    private closingEntries: Collection<GLClosingEntry>,
    private events: EventBus,
  ) {}

  // ========================================================================
  // HELPERS
  // ========================================================================

  /**
   * Infer the normal balance direction from an account type.
   * Assets, expenses, and cost of revenue have debit normal balances.
   * Liabilities, equity, and revenue have credit normal balances.
   */
  inferNormalBalance(type: AccountType): NormalBalance {
    switch (type) {
      case 'asset':
      case 'expense':
      case 'costOfRevenue':
        return 'debit';
      case 'liability':
      case 'equity':
      case 'revenue':
        return 'credit';
    }
  }

  /**
   * Compute the hierarchy depth of an account by walking the parent chain.
   * Root accounts (no parentId) have depth 0.
   */
  computeAccountDepth(
    account: { parentId?: string },
    allAccounts: Array<GLAccount & CollectionMeta>,
  ): number {
    let depth = 0;
    let currentParentId = account.parentId;
    const visited = new Set<string>();

    while (currentParentId) {
      if (visited.has(currentParentId)) {
        break; // Prevent infinite loop on circular references
      }
      visited.add(currentParentId);
      const parent = allAccounts.find((a) => a.id === currentParentId);
      if (!parent) break;
      depth += 1;
      currentParentId = parent.parentId;
    }

    return depth;
  }

  /**
   * Compute the full path of an account by walking up the parent chain
   * and joining account numbers with dots.
   * Example: "1000.1100.1110"
   */
  computeAccountPath(
    account: { number: string; parentId?: string },
    allAccounts: Array<GLAccount & CollectionMeta>,
  ): string {
    const segments: string[] = [account.number];
    let currentParentId = account.parentId;
    const visited = new Set<string>();

    while (currentParentId) {
      if (visited.has(currentParentId)) {
        break; // Prevent infinite loop on circular references
      }
      visited.add(currentParentId);
      const parent = allAccounts.find((a) => a.id === currentParentId);
      if (!parent) break;
      segments.unshift(parent.number);
      currentParentId = parent.parentId;
    }

    return segments.join('.');
  }

  /**
   * Generate the next journal entry number for the current year.
   * Format: JE-YYYY-NNNNN (5-digit zero-padded sequence)
   */
  private async generateEntryNumber(): Promise<string> {
    const year = new Date().getFullYear();
    const prefix = `JE-${year}-`;

    const existing = await this.journalEntries
      .query()
      .where('entryNumber', 'startsWith', prefix)
      .execute();

    let maxSeq = 0;
    for (const entry of existing) {
      const parts = entry.entryNumber.split('-');
      const seq = parseInt(parts[2] || '0', 10);
      if (seq > maxSeq) {
        maxSeq = seq;
      }
    }

    return `${prefix}${String(maxSeq + 1).padStart(5, '0')}`;
  }

  /**
   * Compute the next run date for a recurring entry given its frequency.
   */
  computeNextRunDate(
    lastDate: string,
    frequency: GLRecurringEntry['frequency'],
  ): string {
    const d = new Date(lastDate);
    switch (frequency) {
      case 'daily':
        d.setDate(d.getDate() + 1);
        break;
      case 'weekly':
        d.setDate(d.getDate() + 7);
        break;
      case 'monthly':
        d.setMonth(d.getMonth() + 1);
        break;
      case 'quarterly':
        d.setMonth(d.getMonth() + 3);
        break;
      case 'yearly':
        d.setFullYear(d.getFullYear() + 1);
        break;
    }
    return d.toISOString().split('T')[0];
  }

  // ========================================================================
  // ACCOUNT MANAGEMENT
  // ========================================================================

  /**
   * Create a new GL account.
   * Auto-computes depth and path from parentId.
   * Checks account number uniqueness.
   * Infers normalBalance from type if not explicitly provided.
   */
  async createAccount(data: {
    number: string;
    name: string;
    type: AccountType;
    normalBalance?: NormalBalance;
    parentId?: string;
    description?: string;
    isActive?: boolean;
    isSummary?: boolean;
  }): Promise<GLAccount & CollectionMeta> {
    // Validate account number uniqueness
    const existingByNumber = await this.getAccountByNumber(data.number);
    if (existingByNumber) {
      throw new Error(`Account number "${data.number}" already exists.`);
    }

    // Infer normal balance from type if not provided
    const normalBalance = data.normalBalance || this.inferNormalBalance(data.type);

    // Fetch all accounts to compute depth and path
    const allAccounts = await this.accounts.query().orderBy('number', 'asc').execute();

    // Validate parent exists if specified
    if (data.parentId) {
      const parent = allAccounts.find((a) => a.id === data.parentId);
      if (!parent) {
        throw new Error(`Parent account not found: ${data.parentId}`);
      }
    }

    const depth = this.computeAccountDepth(data, allAccounts);
    const path = this.computeAccountPath(data, allAccounts);

    const record = await this.accounts.insert({
      number: data.number,
      name: data.name,
      type: data.type,
      normalBalance,
      parentId: data.parentId,
      description: data.description,
      isActive: data.isActive !== undefined ? data.isActive : true,
      isSummary: data.isSummary ?? false,
      depth,
      path,
    } as GLAccount);

    this.events.emit('gl.account.created', { account: record });
    return record;
  }

  /**
   * Update an existing GL account.
   * If type changes, normalBalance is re-inferred.
   */
  async updateAccount(
    id: string,
    changes: Partial<GLAccount>,
  ): Promise<GLAccount & CollectionMeta> {
    const existing = await this.accounts.get(id);
    if (!existing) {
      throw new Error(`Account not found: ${id}`);
    }

    // If type changed, update normal balance
    if (changes.type && changes.type !== existing.type) {
      changes.normalBalance = changes.normalBalance || this.inferNormalBalance(changes.type);
    }

    // If number or parentId changed, recompute depth and path
    if (changes.number !== undefined || changes.parentId !== undefined) {
      const allAccounts = await this.accounts.query().orderBy('number', 'asc').execute();
      const merged = {
        number: changes.number ?? existing.number,
        parentId: changes.parentId !== undefined ? changes.parentId : existing.parentId,
      };
      changes.depth = this.computeAccountDepth(merged, allAccounts);
      changes.path = this.computeAccountPath(merged, allAccounts);
    }

    const updated = await this.accounts.update(id, changes);
    this.events.emit('gl.account.updated', { account: updated });
    return updated;
  }

  /**
   * Delete (soft-delete) an account.
   * Refuses if any journal lines reference this account.
   */
  async deleteAccount(id: string): Promise<void> {
    const existing = await this.accounts.get(id);
    if (!existing) {
      throw new Error(`Account not found: ${id}`);
    }

    // Check for journal lines referencing this account
    const usageCount = await this.journalLines
      .query()
      .where('accountId', '=', id)
      .count();

    if (usageCount > 0) {
      throw new Error(
        `Cannot delete account: it is referenced by ${usageCount} journal line(s). Deactivate it instead.`,
      );
    }

    // Check for child accounts
    const childCount = await this.accounts
      .query()
      .where('parentId', '=', id)
      .count();

    if (childCount > 0) {
      throw new Error(
        `Cannot delete account: it has ${childCount} child account(s). Remove or reassign them first.`,
      );
    }

    await this.accounts.remove(id);
    this.events.emit('gl.account.deleted', { accountId: id });
  }

  /**
   * Get a single account by ID.
   */
  async getAccount(id: string): Promise<(GLAccount & CollectionMeta) | null> {
    return this.accounts.get(id);
  }

  /**
   * Get accounts with optional filters, ordered by number.
   */
  async getAccounts(filters?: {
    type?: AccountType;
    isActive?: boolean;
  }): Promise<(GLAccount & CollectionMeta)[]> {
    const q = this.accounts.query();

    if (filters?.type) {
      q.where('type', '=', filters.type);
    }
    if (filters?.isActive !== undefined) {
      q.where('isActive', '=', filters.isActive);
    }

    q.orderBy('number', 'asc');
    return q.execute();
  }

  /**
   * Build a tree of accounts based on parentId hierarchy.
   * Returns root-level nodes with nested children.
   */
  async getAccountTree(): Promise<AccountTreeNode[]> {
    const allAccounts = await this.accounts
      .query()
      .orderBy('number', 'asc')
      .execute();

    const nodeMap = new Map<string, AccountTreeNode>();
    const roots: AccountTreeNode[] = [];

    // Create nodes for all accounts
    for (const account of allAccounts) {
      nodeMap.set(account.id, {
        account: account as GLAccount & { id: string },
        children: [],
      });
    }

    // Build tree structure
    for (const account of allAccounts) {
      const node = nodeMap.get(account.id)!;
      if (account.parentId && nodeMap.has(account.parentId)) {
        nodeMap.get(account.parentId)!.children.push(node);
      } else {
        roots.push(node);
      }
    }

    return roots;
  }

  /**
   * Lookup an account by its account number.
   */
  async getAccountByNumber(number: string): Promise<(GLAccount & CollectionMeta) | null> {
    const result = await this.accounts
      .query()
      .where('number', '=', number)
      .limit(1)
      .first();
    return result;
  }

  // ========================================================================
  // JOURNAL ENTRY MANAGEMENT
  // ========================================================================

  /**
   * Create a journal entry with lines, enforcing double-entry bookkeeping.
   *
   * Validations:
   *  - Minimum 2 lines
   *  - Each line has debit OR credit (not both nonzero)
   *  - Total debits = total credits (within 0.005 tolerance)
   *  - All referenced accounts exist and are active
   *
   * Auto-generates entryNumber in the format JE-YYYY-NNNNN.
   * Creates the entry in draft status, then creates all journal lines
   * with denormalized account info.
   */
  async createJournalEntry(data: {
    date: string;
    reference?: string;
    description?: string;
    lines: Array<{
      accountId: string;
      debit: number;
      credit: number;
      description?: string;
    }>;
    sourceModule?: string;
    sourceId?: string;
  }): Promise<{ entry: GLJournalEntry & CollectionMeta; lines: (GLJournalLine & CollectionMeta)[] }> {
    const { lines } = data;

    // Validate minimum 2 lines
    if (lines.length < 2) {
      throw new Error('A journal entry must have at least 2 lines.');
    }

    // Validate each line: debit or credit, not both nonzero
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const hasDebit = (line.debit ?? 0) > 0;
      const hasCredit = (line.credit ?? 0) > 0;

      if (hasDebit && hasCredit) {
        throw new Error(
          `Line ${i + 1}: cannot have both debit and credit amounts on the same line.`,
        );
      }
      if (!hasDebit && !hasCredit) {
        throw new Error(
          `Line ${i + 1}: must have either a debit or credit amount.`,
        );
      }
    }

    // Validate all accounts exist and are active
    const accountCache = new Map<string, GLAccount & CollectionMeta>();
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!accountCache.has(line.accountId)) {
        const account = await this.accounts.get(line.accountId);
        if (!account) {
          throw new Error(`Line ${i + 1}: account not found: ${line.accountId}`);
        }
        if (!account.isActive) {
          throw new Error(
            `Line ${i + 1}: account "${account.number} - ${account.name}" is inactive.`,
          );
        }
        accountCache.set(line.accountId, account);
      }
    }

    // Calculate totals
    const totalDebit = lines.reduce((sum, l) => sum + (l.debit || 0), 0);
    const totalCredit = lines.reduce((sum, l) => sum + (l.credit || 0), 0);

    // Double-entry enforcement: debits must equal credits
    if (Math.abs(totalDebit - totalCredit) > 0.005) {
      throw new Error(
        `Journal entry is out of balance. Debits: ${totalDebit.toFixed(2)}, Credits: ${totalCredit.toFixed(2)}, Difference: ${Math.abs(totalDebit - totalCredit).toFixed(2)}`,
      );
    }

    // Generate entry number
    const entryNumber = await this.generateEntryNumber();

    // Create the journal entry in draft status
    const entry = await this.journalEntries.insert({
      entryNumber,
      date: data.date,
      reference: data.reference,
      description: data.description,
      status: 'draft',
      totalDebit: Math.round(totalDebit * 100) / 100,
      totalCredit: Math.round(totalCredit * 100) / 100,
      sourceModule: data.sourceModule,
      sourceId: data.sourceId,
      isAutoGenerated: false,
    } as Omit<GLJournalEntry, keyof CollectionMeta>);

    // Create journal lines with denormalized account info
    const createdLines: (GLJournalLine & CollectionMeta)[] = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const account = accountCache.get(line.accountId)!;

      const journalLine = await this.journalLines.insert({
        journalEntryId: entry.id,
        accountId: line.accountId,
        accountNumber: account.number,
        accountName: account.name,
        debit: line.debit || 0,
        credit: line.credit || 0,
        description: line.description,
        lineOrder: i + 1,
      } as Omit<GLJournalLine, keyof CollectionMeta>);

      createdLines.push(journalLine);
    }

    this.events.emit('gl.journalEntry.created', { entry, lines: createdLines });
    return { entry, lines: createdLines };
  }

  /**
   * Post a journal entry (change status from draft to posted).
   * Only draft entries can be posted.
   */
  async postJournalEntry(id: string): Promise<GLJournalEntry & CollectionMeta> {
    const entry = await this.journalEntries.get(id);
    if (!entry) {
      throw new Error(`Journal entry not found: ${id}`);
    }
    if (entry.status !== 'draft') {
      throw new Error(
        `Can only post entries in "draft" status. Current status: "${entry.status}".`,
      );
    }

    // Check if fiscal period is open (if assigned)
    if (entry.fiscalPeriodId) {
      const period = await this.fiscalPeriods.get(entry.fiscalPeriodId);
      if (period && period.status !== 'open') {
        throw new Error(
          `Fiscal period "${period.name}" is ${period.status}. Cannot post entries to a non-open period.`,
        );
      }
    }

    const updated = await this.journalEntries.update(id, {
      status: 'posted',
      postedAt: now(),
    } as Partial<GLJournalEntry>);

    this.events.emit('gl.journalEntry.posted', { entry: updated });
    return updated;
  }

  /**
   * Void a posted journal entry.
   * Only posted entries can be voided.
   */
  async voidJournalEntry(
    id: string,
    reason: string,
  ): Promise<GLJournalEntry & CollectionMeta> {
    const entry = await this.journalEntries.get(id);
    if (!entry) {
      throw new Error(`Journal entry not found: ${id}`);
    }
    if (entry.status !== 'posted') {
      throw new Error(
        `Can only void entries in "posted" status. Current status: "${entry.status}".`,
      );
    }
    if (!reason || reason.trim().length === 0) {
      throw new Error('A void reason is required.');
    }

    const updated = await this.journalEntries.update(id, {
      status: 'voided',
      voidedAt: now(),
      voidReason: reason.trim(),
    } as Partial<GLJournalEntry>);

    this.events.emit('gl.journalEntry.voided', { entry: updated, reason });
    return updated;
  }

  /**
   * Get a single journal entry with its lines.
   */
  async getJournalEntry(
    id: string,
  ): Promise<{
    entry: GLJournalEntry & CollectionMeta;
    lines: (GLJournalLine & CollectionMeta)[];
  } | null> {
    const entry = await this.journalEntries.get(id);
    if (!entry) return null;

    const lines = await this.journalLines
      .query()
      .where('journalEntryId', '=', id)
      .orderBy('lineOrder', 'asc')
      .execute();

    return { entry, lines };
  }

  /**
   * Get journal entries with optional filters.
   */
  async getJournalEntries(filters?: {
    status?: string;
    startDate?: string;
    endDate?: string;
  }): Promise<(GLJournalEntry & CollectionMeta)[]> {
    const q = this.journalEntries.query();

    if (filters?.status) {
      q.where('status', '=', filters.status);
    }
    if (filters?.startDate) {
      q.where('date', '>=', filters.startDate);
    }
    if (filters?.endDate) {
      q.where('date', '<=', filters.endDate);
    }

    q.orderBy('date', 'desc');
    return q.execute();
  }

  /**
   * Get all journal lines for a specific entry, ordered by lineOrder.
   */
  async getJournalLines(
    entryId: string,
  ): Promise<(GLJournalLine & CollectionMeta)[]> {
    return this.journalLines
      .query()
      .where('journalEntryId', '=', entryId)
      .orderBy('lineOrder', 'asc')
      .execute();
  }

  // ========================================================================
  // FISCAL PERIODS
  // ========================================================================

  /**
   * Generate 12 monthly fiscal periods for a given year.
   * Creates periods named like "January 2026", "February 2026", etc.
   */
  async generateFiscalPeriods(year: number): Promise<(GLFiscalPeriod & CollectionMeta)[]> {
    const periods: (GLFiscalPeriod & CollectionMeta)[] = [];

    for (let month = 1; month <= 12; month++) {
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0); // last day of month

      const monthName = startDate.toLocaleString('default', { month: 'long' });

      const period = await this.fiscalPeriods.insert({
        name: `${monthName} ${year}`,
        year,
        month,
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        status: 'open',
      } as Omit<GLFiscalPeriod, keyof CollectionMeta>);

      periods.push(period);
    }

    this.events.emit('gl.fiscalPeriods.generated', { year, count: periods.length });
    return periods;
  }

  /**
   * Close a fiscal period.
   * Validates that no draft journal entries exist in the period before closing.
   */
  async closeFiscalPeriod(id: string): Promise<GLFiscalPeriod & CollectionMeta> {
    const period = await this.fiscalPeriods.get(id);
    if (!period) {
      throw new Error(`Fiscal period not found: ${id}`);
    }
    if (period.status === 'closed') {
      throw new Error(`Period "${period.name}" is already closed.`);
    }
    if (period.status === 'locked') {
      throw new Error(`Period "${period.name}" is locked and cannot be modified.`);
    }

    // Check for draft journal entries in this period date range
    const draftEntries = await this.journalEntries
      .query()
      .where('status', '=', 'draft')
      .where('date', '>=', period.startDate)
      .where('date', '<=', period.endDate)
      .execute();

    if (draftEntries.length > 0) {
      throw new Error(
        `Cannot close period "${period.name}": ${draftEntries.length} draft journal entry(ies) exist in this period. Post or delete them first.`,
      );
    }

    const updated = await this.fiscalPeriods.update(id, {
      status: 'closed',
      closedAt: now(),
    } as Partial<GLFiscalPeriod>);

    this.events.emit('gl.period.closed', { period: updated });
    return updated;
  }

  /**
   * Reopen a closed fiscal period (set status back to open).
   */
  async reopenFiscalPeriod(id: string): Promise<GLFiscalPeriod & CollectionMeta> {
    const period = await this.fiscalPeriods.get(id);
    if (!period) {
      throw new Error(`Fiscal period not found: ${id}`);
    }
    if (period.status === 'open') {
      throw new Error(`Period "${period.name}" is already open.`);
    }
    if (period.status === 'locked') {
      throw new Error(`Period "${period.name}" is locked and cannot be reopened.`);
    }

    const updated = await this.fiscalPeriods.update(id, {
      status: 'open',
      closedAt: undefined,
    } as Partial<GLFiscalPeriod>);

    this.events.emit('gl.period.reopened', { period: updated });
    return updated;
  }

  /**
   * Get fiscal periods, optionally filtered by year.
   */
  async getFiscalPeriods(year?: number): Promise<(GLFiscalPeriod & CollectionMeta)[]> {
    const q = this.fiscalPeriods.query();

    if (year !== undefined) {
      q.where('year', '=', year);
    }

    q.orderBy('startDate', 'asc');
    return q.execute();
  }

  /**
   * Find the fiscal period that contains today's date.
   */
  async getCurrentPeriod(): Promise<(GLFiscalPeriod & CollectionMeta) | null> {
    const today = new Date().toISOString().split('T')[0];

    const period = await this.fiscalPeriods
      .query()
      .where('startDate', '<=', today)
      .where('endDate', '>=', today)
      .limit(1)
      .first();

    return period;
  }

  // ========================================================================
  // RECURRING ENTRIES
  // ========================================================================

  /**
   * Create a recurring journal entry template.
   */
  async createRecurringEntry(data: {
    name: string;
    description?: string;
    frequency: GLRecurringEntry['frequency'];
    isActive?: boolean;
    nextRunDate?: string;
    endDate?: string;
    templateLines: GLRecurringEntry['templateLines'];
  }): Promise<GLRecurringEntry & CollectionMeta> {
    const record = await this.recurringEntries.insert({
      name: data.name,
      description: data.description,
      frequency: data.frequency,
      isActive: data.isActive !== undefined ? data.isActive : true,
      nextRunDate: data.nextRunDate,
      endDate: data.endDate,
      templateLines: data.templateLines,
      runCount: 0,
    } as GLRecurringEntry);

    this.events.emit('gl.recurringEntry.created', { recurringEntry: record });
    return record;
  }

  /**
   * Execute a recurring entry: generate a journal entry from its template,
   * update nextRunDate, lastRunDate, and runCount.
   */
  async executeRecurringEntry(
    id: string,
  ): Promise<{ entry: GLJournalEntry & CollectionMeta; lines: (GLJournalLine & CollectionMeta)[] }> {
    const recurring = await this.recurringEntries.get(id);
    if (!recurring) {
      throw new Error(`Recurring entry not found: ${id}`);
    }
    if (!recurring.isActive) {
      throw new Error(`Recurring entry "${recurring.name}" is not active.`);
    }

    // Check if past end date
    const today = new Date().toISOString().split('T')[0];
    if (recurring.endDate && today > recurring.endDate) {
      throw new Error(
        `Recurring entry "${recurring.name}" has passed its end date (${recurring.endDate}).`,
      );
    }

    // Create a journal entry from the template
    const result = await this.createJournalEntry({
      date: today,
      description: `Recurring: ${recurring.name}`,
      lines: recurring.templateLines.map((tl) => ({
        accountId: tl.accountId,
        debit: tl.debit,
        credit: tl.credit,
        description: tl.description,
      })),
    });

    // Compute next run date
    const nextRunDate = this.computeNextRunDate(today, recurring.frequency);

    // Update the recurring entry metadata
    await this.recurringEntries.update(id, {
      lastRunDate: today,
      nextRunDate,
      runCount: recurring.runCount + 1,
    } as Partial<GLRecurringEntry>);

    this.events.emit('gl.recurringEntry.executed', {
      recurringEntryId: id,
      journalEntryId: result.entry.id,
    });

    return result;
  }

  /**
   * Find all recurring entries that are due to run (nextRunDate <= today and isActive).
   */
  async getDueRecurringEntries(): Promise<(GLRecurringEntry & CollectionMeta)[]> {
    const today = new Date().toISOString().split('T')[0];

    return this.recurringEntries
      .query()
      .where('isActive', '=', true)
      .where('nextRunDate', '<=', today)
      .execute();
  }

  /**
   * List all recurring entries.
   */
  async getRecurringEntries(): Promise<(GLRecurringEntry & CollectionMeta)[]> {
    return this.recurringEntries
      .query()
      .orderBy('name', 'asc')
      .execute();
  }

  // ========================================================================
  // CLOSING ENTRIES
  // ========================================================================

  /**
   * Generate closing entries for a fiscal period.
   *
   * Finds all posted revenue/expense/costOfRevenue journal lines in the period,
   * creates closing journal entries to zero out income/expense accounts to
   * retained earnings. Creates GLClosingEntry records to track what was closed.
   *
   * Two journal entries are created:
   *  1. Income Summary: closes revenue and expense accounts to an income summary
   *  2. Retained Earnings: transfers net income to the retained earnings account
   */
  async generateClosingEntries(
    fiscalPeriodId: string,
    retainedEarningsAccountId: string,
  ): Promise<(GLClosingEntry & CollectionMeta)[]> {
    const period = await this.fiscalPeriods.get(fiscalPeriodId);
    if (!period) {
      throw new Error(`Fiscal period not found: ${fiscalPeriodId}`);
    }

    // Verify the retained earnings account exists and is equity type
    const reAccount = await this.accounts.get(retainedEarningsAccountId);
    if (!reAccount) {
      throw new Error(`Retained earnings account not found: ${retainedEarningsAccountId}`);
    }
    if (reAccount.type !== 'equity') {
      throw new Error(
        `Retained earnings account must be of type "equity". Got: "${reAccount.type}".`,
      );
    }

    // Get all posted journal entries in this period's date range
    const postedEntries = await this.journalEntries
      .query()
      .where('status', '=', 'posted')
      .where('date', '>=', period.startDate)
      .where('date', '<=', period.endDate)
      .execute();

    if (postedEntries.length === 0) {
      throw new Error(
        `No posted journal entries found in period "${period.name}". Nothing to close.`,
      );
    }

    const entryIds = postedEntries.map((e) => e.id);

    // Get all journal lines for those entries
    const allLines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .execute();

    // Get all accounts to identify revenue/expense/costOfRevenue
    const allAccountsList = await this.accounts.query().execute();
    const accountMap = new Map(allAccountsList.map((a) => [a.id, a]));

    // Aggregate balances for revenue, expense, and costOfRevenue accounts
    const accountBalances = new Map<string, number>();
    for (const line of allLines) {
      const account = accountMap.get(line.accountId);
      if (!account) continue;
      if (
        account.type !== 'revenue' &&
        account.type !== 'expense' &&
        account.type !== 'costOfRevenue'
      ) {
        continue;
      }

      const current = accountBalances.get(line.accountId) || 0;
      // Track net debit-credit for each account
      accountBalances.set(line.accountId, current + (line.debit || 0) - (line.credit || 0));
    }

    // Build closing journal entry lines: reverse each revenue/expense balance
    const closingLines: Array<{
      accountId: string;
      debit: number;
      credit: number;
      description?: string;
    }> = [];

    let netIncome = 0;

    for (const [accountId, balance] of accountBalances) {
      if (Math.abs(balance) < 0.005) continue;
      const account = accountMap.get(accountId)!;

      // Revenue accounts typically have credit balances (negative net debit-credit).
      // Expense accounts have debit balances (positive net debit-credit).
      // To close: reverse the balance.
      // Net income: revenue credits minus expense debits.
      netIncome -= balance;

      closingLines.push({
        accountId,
        debit: balance < 0 ? Math.abs(balance) : 0,  // If credit balance, debit to close
        credit: balance > 0 ? balance : 0,             // If debit balance, credit to close
        description: `Close ${account.name}`,
      });
    }

    if (closingLines.length === 0) {
      throw new Error(
        `No revenue or expense activity found in period "${period.name}". Nothing to close.`,
      );
    }

    // Add the retained earnings line to balance the entry
    closingLines.push({
      accountId: retainedEarningsAccountId,
      debit: netIncome < 0 ? Math.abs(netIncome) : 0,
      credit: netIncome > 0 ? netIncome : 0,
      description: `Net income to retained earnings for ${period.name}`,
    });

    // Create the closing journal entry
    const closingJE = await this.createJournalEntry({
      date: period.endDate,
      description: `Closing entries for ${period.name}`,
      lines: closingLines,
    });

    // Mark the JE as auto-generated
    await this.journalEntries.update(closingJE.entry.id, {
      isAutoGenerated: true,
    } as Partial<GLJournalEntry>);

    // Create closing entry records
    const createdClosingEntries: (GLClosingEntry & CollectionMeta)[] = [];

    // Record the income-summary closing entry
    const incomeSummaryRecord = await this.closingEntries.insert({
      fiscalPeriodId,
      journalEntryId: closingJE.entry.id,
      type: 'income-summary',
      periodName: period.name,
      totalAmount: Math.abs(netIncome),
    } as Omit<GLClosingEntry, keyof CollectionMeta>);
    createdClosingEntries.push(incomeSummaryRecord);

    // Record the retained-earnings closing entry
    const retainedEarningsRecord = await this.closingEntries.insert({
      fiscalPeriodId,
      journalEntryId: closingJE.entry.id,
      type: 'retained-earnings',
      periodName: period.name,
      totalAmount: netIncome,
    } as Omit<GLClosingEntry, keyof CollectionMeta>);
    createdClosingEntries.push(retainedEarningsRecord);

    this.events.emit('gl.closingEntries.generated', {
      fiscalPeriodId,
      periodName: period.name,
      netIncome,
      journalEntryId: closingJE.entry.id,
    });

    return createdClosingEntries;
  }

  /**
   * List closing entries, optionally filtered by fiscal period.
   */
  async getClosingEntries(
    fiscalPeriodId?: string,
  ): Promise<(GLClosingEntry & CollectionMeta)[]> {
    const q = this.closingEntries.query();

    if (fiscalPeriodId) {
      q.where('fiscalPeriodId', '=', fiscalPeriodId);
    }

    return q.execute();
  }

  // ========================================================================
  // REPORTS
  // ========================================================================

  /**
   * Generate a trial balance report.
   *
   * Aggregates all posted journal lines up to the given date,
   * groups by account, and returns a row per account showing
   * total debits and credits.
   */
  async getTrialBalance(asOfDate?: string): Promise<TrialBalanceRow[]> {
    // Get posted journal entries up to asOfDate
    const jeQuery = this.journalEntries.query().where('status', '=', 'posted');
    if (asOfDate) {
      jeQuery.where('date', '<=', asOfDate);
    }
    const entries = await jeQuery.execute();
    const entryIds = entries.map((e) => e.id);

    if (entryIds.length === 0) {
      return [];
    }

    // Get all lines for those entries
    const lines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .execute();

    // Aggregate debits and credits by account
    const balances = new Map<
      string,
      { debit: number; credit: number }
    >();

    for (const line of lines) {
      const current = balances.get(line.accountId) || { debit: 0, credit: 0 };
      current.debit += line.debit || 0;
      current.credit += line.credit || 0;
      balances.set(line.accountId, current);
    }

    // Get all accounts for display information
    const allAccounts = await this.accounts
      .query()
      .orderBy('number', 'asc')
      .execute();

    // Build result rows
    const rows: TrialBalanceRow[] = [];

    for (const account of allAccounts) {
      const bal = balances.get(account.id);
      if (!bal) continue; // Skip accounts with no activity

      rows.push({
        accountId: account.id,
        accountNumber: account.number,
        accountName: account.name,
        accountType: account.type,
        debit: Math.round(bal.debit * 100) / 100,
        credit: Math.round(bal.credit * 100) / 100,
      });
    }

    return rows;
  }

  /**
   * Generate a GL detail report for a specific account.
   *
   * Returns individual journal entry lines with a running balance,
   * ordered by date and then by entry number.
   */
  async getGLDetail(
    accountId: string,
    startDate?: string,
    endDate?: string,
  ): Promise<GLDetailRow[]> {
    const account = await this.accounts.get(accountId);
    if (!account) {
      throw new Error(`Account not found: ${accountId}`);
    }

    const isDebitNormal = account.normalBalance === 'debit';

    // Compute opening balance: sum all posted lines before startDate
    let openingBalance = 0;
    if (startDate) {
      const priorJeQuery = this.journalEntries
        .query()
        .where('status', '=', 'posted')
        .where('date', '<', startDate);
      const priorEntries = await priorJeQuery.execute();
      const priorEntryIds = priorEntries.map((e) => e.id);

      if (priorEntryIds.length > 0) {
        const priorLines = await this.journalLines
          .query()
          .where('journalEntryId', 'in', priorEntryIds)
          .where('accountId', '=', accountId)
          .execute();

        for (const line of priorLines) {
          openingBalance += isDebitNormal
            ? (line.debit || 0) - (line.credit || 0)
            : (line.credit || 0) - (line.debit || 0);
        }
      }
    }

    // Get posted entries in the date range
    const jeQuery = this.journalEntries
      .query()
      .where('status', '=', 'posted');

    if (startDate) {
      jeQuery.where('date', '>=', startDate);
    }
    if (endDate) {
      jeQuery.where('date', '<=', endDate);
    }

    jeQuery.orderBy('date', 'asc');
    const entries = await jeQuery.execute();

    if (entries.length === 0) {
      return [];
    }

    const entryIds = entries.map((e) => e.id);
    const entryMap = new Map(entries.map((e) => [e.id, e]));

    // Get lines for this account from those entries
    const lines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .where('accountId', '=', accountId)
      .execute();

    // Sort lines by the date and entryNumber of their parent journal entry, then by lineOrder
    const sortedLines = lines.sort((a, b) => {
      const jeA = entryMap.get(a.journalEntryId);
      const jeB = entryMap.get(b.journalEntryId);
      if (!jeA || !jeB) return 0;

      const dateCompare = jeA.date.localeCompare(jeB.date);
      if (dateCompare !== 0) return dateCompare;

      const numCompare = jeA.entryNumber.localeCompare(jeB.entryNumber);
      if (numCompare !== 0) return numCompare;

      return (a.lineOrder || 0) - (b.lineOrder || 0);
    });

    // Build detail rows with running balance
    let runningBalance = openingBalance;
    const rows: GLDetailRow[] = [];

    for (const line of sortedLines) {
      const je = entryMap.get(line.journalEntryId);
      if (!je) continue;

      runningBalance += isDebitNormal
        ? (line.debit || 0) - (line.credit || 0)
        : (line.credit || 0) - (line.debit || 0);

      rows.push({
        date: je.date,
        entryNumber: je.entryNumber,
        journalEntryId: je.id,
        description: line.description || je.description || '',
        debit: line.debit || 0,
        credit: line.credit || 0,
        balance: Math.round(runningBalance * 100) / 100,
      });
    }

    return rows;
  }

  // ========================================================================
  // ACCOUNT BALANCE
  // ========================================================================

  /**
   * Get the balance for a single account as of a given date.
   *
   * Sums all posted debits and credits for the account, then returns
   * the net balance respecting the account's normal balance direction.
   * - Debit-normal accounts: balance = debits - credits
   * - Credit-normal accounts: balance = credits - debits
   */
  async getAccountBalance(
    accountId: string,
    asOfDate?: string,
  ): Promise<number> {
    const account = await this.accounts.get(accountId);
    if (!account) {
      return 0;
    }

    // Get posted journal entries up to asOfDate
    const jeQuery = this.journalEntries
      .query()
      .where('status', '=', 'posted');

    if (asOfDate) {
      jeQuery.where('date', '<=', asOfDate);
    }

    const entries = await jeQuery.execute();
    const entryIds = entries.map((e) => e.id);

    if (entryIds.length === 0) {
      return 0;
    }

    // Get all lines for this account from those entries
    const lines = await this.journalLines
      .query()
      .where('journalEntryId', 'in', entryIds)
      .where('accountId', '=', accountId)
      .execute();

    const isDebitNormal = account.normalBalance === 'debit';
    let balance = 0;

    for (const line of lines) {
      balance += isDebitNormal
        ? (line.debit || 0) - (line.credit || 0)
        : (line.credit || 0) - (line.debit || 0);
    }

    return Math.round(balance * 100) / 100;
  }
}
